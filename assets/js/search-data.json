{"0": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "Activity 1: User Stories and Conditions of Satisfaction",
    "content": "Introduction . This activity will give you practice with using user stories to solicit and document user requirements, refining them into conditions of satisfaction, and assigning priorities. Before you start, be sure to review the tutorial User Stories and Conditions of Satisfaction on the course website. Scenario . Consider a Learning Management System (like Canvas). Choose one of the following areas: . | Sections and Enrollment | Assignment Submission and Grading | Gradebooks | . Requirements for this activity . | Identify at least 3 different roles representing different classes of users for that area. | Choose one of those roles and write down at least 3 different user stories for that participant. These should be of the form . As a &lt;role&gt; I want &lt;some capability&gt; so that I can &lt;get some benefit&gt; . | For each user story, write 3 conditions of satisfaction with appropriate priorities. (Essential = user story is not satisfied without it) . | . Please submit a total of: . | 1 area | 3 roles | 3 user stories | 9 conditions of satisfaction with priorities | . When you are done, submit your work as required by your instructor. This may vary from section to section. ",
    "url": "/CS4530-Fall-2024/Activities/Module01%20Activity/#activity-1-user-stories-and-conditions-of-satisfaction",
    
    "relUrl": "/Activities/Module01%20Activity/#activity-1-user-stories-and-conditions-of-satisfaction"
  },"1": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Conditions of Satisfaction",
    "content": " ",
    "url": "/CS4530-Fall-2024/Activities/Module01%20Activity/",
    
    "relUrl": "/Activities/Module01%20Activity/"
  },"2": {
    "doc": "Test-Driven Development",
    "title": "Test-Driven Development",
    "content": "This activity is intended to supplement the CS4530 lecture on test-driven development. Steps . | Download and unpack the starter Code | Write down the testable behaviors for the satisfaction condition: “Add a new grade for an existing student” | Identify at least two exceptional conditions or design decisions associated with these testable behaviors | Write Jest tests for your testable behaviors | Implement a method addGrade that passes your tests. | . When you are done, submit your work as required by your instructor. This may vary from section to section. ",
    "url": "/CS4530-Fall-2024/Activities/Module02%20Activity/",
    
    "relUrl": "/Activities/Module02%20Activity/"
  },"3": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": " ",
    "url": "/CS4530-Fall-2024/announcements/",
    
    "relUrl": "/announcements/"
  },"4": {
    "doc": "Announcements",
    "title": "Welcome to CS4530 - Fall 2024",
    "content": "Sep 3 &middot; 1 min read On behalf of the entire instructional team (all 2 instructors and 14 TAs), welcome to the Fall 2024 edition of CS 4530! This website will contain all of the lectures, assignments and tutorials for the class. Our Canvas site contains your gradebook as well as single-sign-on links to Piazza (for discussion), instructions for submitting assignments and replicates much of the material from the class website. In advance of the first week of class, we’ve shared the calendars for each section, the first two lectures, and tutorials on installing your IDE, Typescript, and unit testing with Jest. The schedule of office hours is also posted and we will start holding office hours from Thursday Sep 5th. The first individual project deliverable is now available. This deliverable is due by September 18th at 12pm (Noon) ET. Your work will be submitted through github Classroom. We would encourage you to start working on this assignment early. Feel free to use piazza to ask questions and use office hours if you need help. We have 70 hours of scheduled TA office hours per week. We are excited to meet you all this week! . ",
    "url": "/CS4530-Fall-2024/announcements/",
    
    "relUrl": "/announcements/"
  },"5": {
    "doc": "Announcements",
    "title": "Initial Website Launched",
    "content": "Aug 4 &middot; 0 min read Welcome to the course website for CS4530, Fall 2024! Over the coming weeks, we will be populating this website (and Canvas) with more information about the course. ",
    "url": "/CS4530-Fall-2024/announcements/",
    
    "relUrl": "/announcements/"
  },"6": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": " ",
    "url": "/CS4530-Fall-2024/assignments/",
    
    "relUrl": "/assignments/"
  },"7": {
    "doc": "Debugging",
    "title": "Debugging",
    "content": "One of the objectives of this class is to provide students with experiences writing new code for large, existing codebases. We anticipate that you may run into difficulties debugging the project code: it is often difficult to build debugging skills until you have a problem in front of you that requires them. The course staff is happy to help you with debugging, with the specific goal of helping you learn to successfully apply scientific debugging. Andreas Zeller’s Debugging Book provides an excellent guide to scientific debugging. The short version is roughly: if you can’t debug an issue in the first few minutes “just by looking at it”, it will be hard to keep all of the relevant information in your head at once, and a formal process to help you generate and refine guesses for why something is wrong can be immensely useful. The key idea is to create a debugging note file, where you track information like: . | What was the input/application state that caused the bug? | What was the behavior that I expected? | What was the behavior that I observed? | What are possible hypotheses for that behavior? | How have I tested those hypotheses, and what was the result? | . The overall goal with hypothesis formulation is to come up with possible causes for why the bug exists. Then, as long as those hypotheses are testable, we can prove or disprove them. Most hypotheses will be along the lines of “did I make an incorrect assumption about how a library or API works.” The devil is in enumerating all of the possible incorrect assumptions that you might have made, and testing them. The best way to attack these kinds of problems is to start with testing some high-level, general assumptions, and then refine them. If you come to us for debugging help, we will ask you to answer these 5 questions, as our goal is to help you get better at debugging and not to simply point out bugs that we might have seen before. We are happy to discuss the problematic behavior that you are observing, possible hypotheses for why that behavior is occurring, and strategies to test those hypotheses. In the past, students have found that using a variety of strategies to test their hypotheses (e.g. using a debugger, creating a minimized test case, measured application of console.log statements, internet research) are useful, and we would be happy to demonstrate these. We may not be able to stay with you while you work on refining your hypotheses and fixing the bug, but would be happy to continue following up if you get stuck again. ",
    "url": "/CS4530-Fall-2024/policies/debugging/",
    
    "relUrl": "/policies/debugging/"
  },"8": {
    "doc": "CS4530, Fall 2024",
    "title": "CS4530, Fall 2024: Fundamentals of Software Engineering",
    "content": " ",
    "url": "/CS4530-Fall-2024/#cs4530-fall-2024-fundamentals-of-software-engineering",
    
    "relUrl": "/#cs4530-fall-2024-fundamentals-of-software-engineering"
  },"9": {
    "doc": "CS4530, Fall 2024",
    "title": "Welcome to CS4530 - Fall 2024",
    "content": "Sep 3 &middot; 1 min read On behalf of the entire instructional team (all 2 instructors and 14 TAs), welcome to the Fall 2024 edition of CS 4530! This website will contain all of the lectures, assignments and tutorials for the class. Our Canvas site contains your gradebook as well as single-sign-on links to Piazza (for discussion), instructions for submitting assignments and replicates much of the material from the class website. In advance of the first week of class, we’ve shared the calendars for each section, the first two lectures, and tutorials on installing your IDE, Typescript, and unit testing with Jest. The schedule of office hours is also posted and we will start holding office hours from Thursday Sep 5th. The first individual project deliverable is now available. This deliverable is due by September 18th at 12pm (Noon) ET. Your work will be submitted through github Classroom. We would encourage you to start working on this assignment early. Feel free to use piazza to ask questions and use office hours if you need help. We have 70 hours of scheduled TA office hours per week. We are excited to meet you all this week! . Announcements . ",
    "url": "/CS4530-Fall-2024/",
    
    "relUrl": "/"
  },"10": {
    "doc": "CS4530, Fall 2024",
    "title": "Overview",
    "content": "Building, delivering and maintaining successful software products requires more than being good at programming. Software engineering encompasses the tools and processes that we use to design, construct and maintain programs over time. Software engineering has been said to consider the “multi person development of multi version programs.” Development processes that work well for a single developer do not scale to large or even medium-sized teams. Similarly, development processes that work well for quickly delivering a one-off program to a client cause chaos when applied to a codebase that needs to be maintained and updated over months and years. This class will begin to explore these tradeoffs throughout the entire software development lifecycle, with a particular focus on how these decisions affect the quality of the resulting software. This class will serve as an introduction to the field of software engineering, covering key topics such as: . | Requirements gathering and specification How to make sure that you build the product that your customer really wants | Designing code for reuse, for readability, and for scale How to avoid reinventing the wheel? What makes code readable? Where does performance fit into designs? When do we decide when to revisit old design decisions, and how do we replace them? Can we avoid the mistakes that past developers have made? | How to organize your development process to collaborate effectively How do we communicate our designs with others? How do we structure and coordinate development activities? How do we measure the performance of these processes, and tweak them over time? | How to ensure that your code works, is secure, and broadly speaking, “does the right thing” How do we measure different quality attributes like usability, scalability and performance? How do we minimize the cost of defects? How do we automatically test complex systems? Can we automatically prove the absence of some kinds of defects? | . ",
    "url": "/CS4530-Fall-2024/#overview",
    
    "relUrl": "/#overview"
  },"11": {
    "doc": "CS4530, Fall 2024",
    "title": "Course Outcomes",
    "content": ". | Students will be able to define and describe the phases of the software engineering lifecycle (requirements, design, implementation, testing, deployment, maintenance) | Students will be able to explain the role of key processes and technologies in modern software development. | Students will be able to productively apply instances of major tools used in elementary SE tasks. | Students will design and implement a portfolio-worthy software engineering project in a small team environment that can be publicly showcased to recruiters. | . Course Delivery . The course will be delivered in a “traditional” lecture style. Prof Wand’s section will be entirely virtual, and the other sections will be entirely on-the-ground, with no virtual participation option. You must attend the section for which you have registered, and you may not partner with students in other sections for the term project. | Section | Instructor | Meeting Time | Meeting Place | . | 1 | Prof Bhutta | MR 11:45 am - 1:25 pm | West Village G 106 | . | 2 | Prof Bhutta | TF 9:50 am - 11:30 am | EXP 204 | . | 5 | Prof Bhutta | T 11:45 am - 1:25 pm &amp; R 2:50 pm - 4:30pm | Dodge Hall 230 | . | 8 | Prof Bhutta | TF 3:25 pm - 5:05 pm | Shillman Hall 425 | . | 9 | Prof Wand | W 6:00 pm - 9:20 pm | Online | . ",
    "url": "/CS4530-Fall-2024/#course-outcomes",
    
    "relUrl": "/#course-outcomes"
  },"12": {
    "doc": "CS4530, Fall 2024",
    "title": "Course Project",
    "content": "The assignments and project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement new features. The codebase that we’ll be developing on is a Fake Stack Overflow project. You will get an opportunity to work with the starter code which provides basic skeleton for the app and then additional features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. At the end of the semester, the instructors and TAs will evaluate all of the student projects, and select the best (in terms of usability, code quality, test suite quality, and overall design) to showcase on course website. The project will provide hands-on experience to complement the skills taught in this class, requiring students to be able to: . | Work effectively in a small team | Enumerate and prioritize development tasks | Propose, design, implement and test a new feature in an existing non-toy software application | Write code that their team members can read and review | Review teammates’ code | Analyze a proposed software architecture | Use relevant software tools, such as: . | TypeScript | Visual Studio Code (or similar IDE) | Git | Mocha and Jest | Postman | . | . Select projects from Spring 2024 are hosted in our project showcase. Acknowledgements . This class and its contents were inspired by Software Engineering courses at various institutions, including: . | Columbia’s Software Engineering Course, COMS W4156 | CMU’s Software Engineering Course, 17-313 | GMU’s Web App Development Course, SWE 432 | NCSU’s Software Engineering Course, CSC 326 and its iTrust term project, also Chris Parnin’s DevOps course. | Past iterations of CS4530 at Northeastern: Spring 2024, Fall 2023, Spring 2023, Fall 2022, Spring 2022, Spring 2021 | Past iterations of CS5500 at Northeastern, as prepared by Mike Weintraub, Mike Shah, Frank Tip and Joydeep Mitra (Spring 2024). | . This website is built using Kevin Lin’s Just the Class Jekyll template. ",
    "url": "/CS4530-Fall-2024/#course-project",
    
    "relUrl": "/#course-project"
  },"13": {
    "doc": "CS4530, Fall 2024",
    "title": "CS4530, Fall 2024",
    "content": " ",
    "url": "/CS4530-Fall-2024/",
    
    "relUrl": "/"
  },"14": {
    "doc": "Individual Project 1",
    "title": "Change Log",
    "content": ". | 9/6/2024: Added clarification to files required to modify in Task 1 | 9/6/2024: Added clarification/instruction for getTagByName in Task 2 | 9/7/2024: Moved tutorial on MongoDB and Mongoose to tutorials | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#change-log",
    
    "relUrl": "/assignments/ip1#change-log"
  },"15": {
    "doc": "Individual Project 1",
    "title": "Objectives of this assignment",
    "content": "The objectives of this assignment are to: . | Get you familiar with the basics of TypeScript, VSCode, and the project codebase | Learn how to read and write code in TypeScript | Translate high-level requirements into code | Learn how to write unit tests with Jest | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#objectives-of-this-assignment",
    
    "relUrl": "/assignments/ip1#objectives-of-this-assignment"
  },"16": {
    "doc": "Individual Project 1",
    "title": "Getting started with this assignment",
    "content": "Start by accepting our invitation. It will create a Github repository for you which will include the starter code for this assignment. In case you have enrolled in the course recently (after 9/3), you may not find your name in the list. Please create a piazza post to contact us and we will add you to the Github Classroom roster. If you are new to Git, you may want to review this getting started page first! . 1. Prerequisites . 1.1 Install Node.js and npm . If you haven’t installed npm and node.js, follow the tutorial on setting up a development environment for this class . 1.2 Install MongoDB . We use MongoDB as the NoSQL database to store data related to this application. | Follow the instructions in the official MongoDB documentation to install the free community edition. | Choose ‘Install on Linux’, ‘Install on macOS’, or ‘Install on Windows’, depending on your system. (the following steps are for Windows) | Scroll down to the section labeled ‘Install MongoDB Community Edition.’ and click on MongoDB Download Center. | For Windows, in the Package dropdown, select msi. Then download and run the installer. | On Windows, select the “Install MongoDB as a Service” checkbox and install. This will start MongoDB as a background service. | Install “MongoDB Compass” if prompted. | Verify if the MongoDB server is running using the Windows Services app. | . Mongo offers several methods of interacting with your Mongo databases. | MongoDB Compass is an interactive application for creating, modifying, and querying MongoDB connections. It should be started as part of the installation process, showing a connection to mongodb://localhost:27017/. For Windows, install MongoDB Compass using the instructions above. For Mac: . | Download the dmg file from https://www.mongodb.com/try/download/compass. Once the application starts: . | Click on “Add new connection” in the left sidebar. | Make sure the URI field contains mongodb://localhost:27017 | Click on “Connect” - MongoDB will need to be running as a macOS service | . | . | Mongo shell (mongosh) provides a command-line interface that can be used to interact with databases in MongoDB. For Windows: . | Download it here using the msi package. You can also use mongosh to see if the MongoDB server is running. Try the MongoDB Community Edition and the command show dbs; you should see a list of existing databases in your local instance. | . For Mac: . | Mongo shell is automatically installed with MongoDB through the Mac installation instructions. To use it, make sure MongoDB is running as a macOS service, then type mongosh into the terminal. | . | Last and most important, you can use the Mongoose api to interact with MongoDB through your JavaScript or TypeScript programs. Mongoose will be installed as part of the installation process for the project starter code. | . 2. Install the starter code and its dependencies . The starter code package, of which this is a part, is divided into 3 main directories: client, server, and testing. | Navigate to the root directory of the repo. | Install the dependencies for each directory by running the following commands: | . cd client/ npm install cd ../server npm install cd ../testing npm install . Once you install the dependencies, you might see the following ESlint errors in some files. The linter error indicates that the code contains carriage return characters (\\r, represented as ␍) at the end of each line and usually happens when the file has Windows-style line endings (\\r\\n) instead of Unix-style line endings (\\n). To fix this, you can click on the “CRLF” icon on the lower right corner of VSCode and change it to “LF”. Note that this does not count as a linting error when grading. 3. Populate the initial database . | In the server directory, run npx ts-node populate_db.ts mongodb://127.0.0.1:27017/fake_so to populate the fake_so database with data that follows the schema definition. | . Note: Right now, you may run into errors regarding unknown properties. Once you finish implementing Task 2 and Task 4 and modify the schema, you should be able to populate the database correctly. 4. Familiarize Yourself with Project Dependencies . | Ensure the following packages are installed: mongoose, express, jest, eslint, axios, cors, and nodemon. | Refer to the documentation for the following packages: | . | Express is a framework to write server-side code. | The mongoose data modeling library. Mongoose provides JS/TS bindings to MongoDB, so we can manage and manipulate the data from our JS/TS programs. | nodemon accelerates the development by automatically restarting a node application when file changes in the directory are detected. | We use the axios library to send HTTP requests to our server from our client application. | We use cors to regulate the permissible connections between the clients and the server. The current cors configuration allows all connections to the server for convenience. This is fine for a development environment. In a production environment where the application is deployed on a cloud service, the CORS policy needs to be specified more strictly. Read more about CORS https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS. | We use mockingoose to mock Mongoose functions when testing. | . 5. Explore Useful Resources . | Express Tutorial: https://expressjs.com/en/guide/routing.html | MongoDB tutorial: A mini tutorial. | Mongoose Queries: https://mongoosejs.com/docs/queries.html | Mongoose Documents: https://mongoosejs.com/docs/documents.html | Jest Basics: https://jestjs.io/docs/getting-started | Mocking in Jest: https://jestjs.io/docs/mock-functions | Mocking Mongoose functions: https://github.com/alonronin/mockingoose | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#getting-started-with-this-assignment",
    
    "relUrl": "/assignments/ip1#getting-started-with-this-assignment"
  },"17": {
    "doc": "Individual Project 1",
    "title": "Server/Client Architecture",
    "content": "The schemas for the database are documented in the directory server/models/schema. A class diagram for the schema definition is shown below: . The starter code package, of which this is a part, is divided into 3 main directories: client, server, and testing. Client . Running npm run start will start a client on port 3000. The client code uses Axios to send HTTP method requests to the server. You should review the client code to understand how axios sends requests and how the response from the server is processed. You don’t need to make any changes to the client code. Server . The server is responsible for taking HTTP requests from the client and executing them on the database. The server code resides in the server/ directory. The server is responsible for all the data that is sent back and forth to the database. The main server script is in server/server.ts. Running npx ts-node server/server.ts will start an HTTP server, which will take HTTP requests on https://localhost:8000, and execute them on the running database instance. You can send requests to the server using a tool like Postman, or by writing scripts that use axios to send requests to localhost:8000, as you did in the Async activity. When the server is terminated (using CTRL+C), the message “Server closed.” should be displayed. However, the MongoDB service will still be running (You can run mongosh to confirm) . Testing . Unit tests for the server are in server/tests/*.spec.ts. These are written in Jest, which you are already familiar with. To run the entire set of server tests, go to the server directory and say npm run test. Please ensure that the MongoDB server is up and running for the tests to pass. If you want to run specific tests, we recommend that you install vsc-jest-runner in your VSC, and select the test or tests that you would like to run. Summary of the default host/port settings . |   |   | . | Client Instance | https://localhost:3000/ | . | Server Instance | https://localhost:8000/ | . | Database Instance | mongodb://127.0.0.1:27017/fake_so | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#serverclient-architecture",
    
    "relUrl": "/assignments/ip1#serverclient-architecture"
  },"18": {
    "doc": "Individual Project 1",
    "title": "Recommendations when working on the project",
    "content": ". | Open the client application in a browser and interact with it. While interacting, monitor the application tab in the browser’s developer tools. The application tab will give you information about the HTTP requests the client sends to the server. The HTTP requests will contain URIs in their headers. You can use this information to understand the endpoints in the server. | Read the Jest tests. The Jest tests list all the endpoints the server should have, and the types of HTTP method associated with them. Further, the tests also have information about the Mongoose functions that need to be invoked for the service to send a successful response. | Start by defining the schemas in the server/models/schema directory to ensure the data structure is consistent. | Ensure that you run all Jest tests. These tests are designed to catch issues early. Once all Jest tests pass, the Cypress tests should also pass, assuming no significant changes have been made to the client’s implementation. | Follow the debugging policy to help in the debugging process. | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#recommendations-when-working-on-the-project",
    
    "relUrl": "/assignments/ip1#recommendations-when-working-on-the-project"
  },"19": {
    "doc": "Individual Project 1",
    "title": "Implementation Tasks",
    "content": "This deliverable has four parts; each part will be graded on its own rubric. You should complete the assignment one part at a time, in the order presented here. Task 1: Implement Filtering by asked_by Field . The asked_by field in the questions schema represents the username of the user who asked the question, essentially identifying the author of the question. The objective of this task is to enhance the current functionality by adding the capability to filter questions based on the asked_by field. This will allow users to retrieve questions posted by a specific user. Make sure you follow TDD, so work your way up by making sure your code passes the tests in application.spec.ts. Steps to Achieve This . | Add the filterQuestionsByAskedBy function Create a new function called filterQuestionsByAskedBy in the application.ts file. This function will accept a list of questions and the name of a user as arguments and filter the given list of questions, returning only those asked by the specified user. | Update the getQuestionsByFilter function Modify the getQuestionsByFilter function within the questions controller (question.ts) to incorporate the new filtering functionality based on the asked_by field. This involves integrating the filterQuestionsByAskedBy function to ensure that the questions are filtered by the specified user before any other filtering operations. Hint: you may need to look into FindQuestionRequest and make necessary changes. | Testing the implementation After implementing these changes, it’s crucial to thoroughly test the new functionality. Ensure that questions are correctly filtered by the asked_by field and that the existing filtering mechanisms (by search keywords and tags) remain unaffected. To ensure accuracy in your implementation, please add additional tests to application.spec.ts and question.spec.ts and make sure that the code coverage is as comprehensive as possible for the chunks of code you have added or updated as part of this feature. | . Grading for implementation tasks: . | Adding filterQuestionsByAskedBy: 5 points | Updating getQuestionsByFilter: 5 points | Testing: 3 points | . Task 2: Enhancing the Tags Model by Adding a Description Field . The goal of this task is to enhance the existing Tags model by introducing a description field. Tags appear as attributes below questions, acting as labels or keywords used to organize and identify information. For example, the question “How to navigate using React Router?” might have tags like “REACT” and “JAVASCRIPT” to emphasize the languages and frameworks used. This new field will provide users with a descriptive overview of each tag, improving the user experience by clarifying the meaning of tags. For instance, a tag like “ROUTER” might have different meanings depending on the context, such as “a hardware device” or “a file to organize website navigation links.” . The following steps outline the modifications required in the server to accommodate this new field. Steps to Achieve This . | Update the getTags Function The current getTags function in application.ts accepts an array of tag objects, which is only defined to have _id and name. You will first need to change Tag to also include description. Then, this function needs to be modified to do the following: . | Remove duplicate tags, ensuring that if the incoming array of tag objects contains objects with the same name, only the first tag object is used and others are discarded. | Check the database for existing tags. | Create new tags if they do not already exist. | Return the modified tags. | . | Create the getTagByName Function and Endpoint You need to create a new function getTagByName in server/controller/tag.ts. Its expected behavior can be found in server/tests/newTags.spec.ts. You need to ensure that your implementation passes the tests. Hint: see getQuestionById in server/controller/question.ts and addTag in application.ts for how some of the behaviors can be achieved. | Test the Implementation To ensure the accuracy of your implementation, conduct the following tests: . | Test the getTags function correctly handles the creation of new tags, removal of duplicates, and retrieval of existing tags. | Test the getTagByName function to ensure it accurately returns the correct tag data based on the provided name. Consider the case where it cannot find a tag given the name. | . Your implementation needs to pass existing tests. If existing tests are not fully covering every case of your implementation, you need to add additional tests to achieve full coverage in the coverage report. | . Grading for implementation tasks: . | Update getTags: 3 points | Create getTagByName 4 points | Testing: 3 points | . Task 3: Implement Sorting by Most Views . As part of this task, you will be working on a function to retrieve questions based on their view count. You are provided with the getQuestionsByOrder function, which is currently designed to fetch questions from a database and sort them based on the specified order. The function currently supports fetching active, unanswered, and newest questions. Your task is to implement the logic for fetching the most viewed questions. Make sure you follow TDD, so work your way up by understanding and making sure your code passes the tests in application.spec.ts. Steps to Achieve This . | Add the sortQuestionsByMostViewed Function Create a new function called sortQuestionsByMostViewed in the application.ts file. This function should take a list of questions as input and return the questions sorted by their view count in descending order. | Update the getQuestionsByOrder Function Modify the getQuestionsByOrder function within the same file (application.ts) to incorporate the new sorting functionality. This involves utilizing the function implemented in Step 1. | Testing the Implementation After implementing these changes, it’s crucial to thoroughly test the new functionality. Ensure that questions are correctly sorted by most views, and that the existing sorting features (active, unanswered, and newest) remain unaffected. To ensure your implementation is accurate, please add tests in application.spec.ts and ensure the code coverage is as thorough as possible for the portions of code you have added or updated as part of this feature. | . Grading for implementation tasks: . | Add getMostViewedQuestion: 5 points | Update getQuestionsByOrder: 5 points | Testing: 3 points | . Task 4: Implement Upvoting and Downvoting Functionality . Upvoting and downvoting features allow users to express their opinions on questions by adding or removing their votes. This functionality is crucial for a community-driven platform where user engagement and feedback are important. Make sure you follow TDD, so work your way up by understanding and making sure your code passes the tests in application.spec.ts and question.spec.ts. Upvoting a Question . When a user upvotes a question, the following actions take place: . | Update Upvotes List: The user’s username is added to the up_votes field of the question. This field is an array that tracks all the users who have upvoted the question. | Remove Downvote (if present): If the user had previously downvoted the question, their username is removed from the down_votes list to prevent contradictory actions by the same user. | Success and Cancellation: If the user has already upvoted the question, their vote is cancelled, which involves removing their username from the up_votes list. | . Downvoting a Question . Similarly, when a user downvotes a question: . | Update Downvotes List: The user’s username is added to the down_votes field of the question. This field is an array that records all the users who have downvoted the question. | Remove Upvote (if present): If the user had previously upvoted the question, their username is removed from the up_votes list. | Success and Cancellation: If the user has already downvoted the question, their vote is cancelled, which involves removing their username from the down_votes list. | . Key Points . | Each question maintains two separate lists: up_votes and down_votes, which are updated based on user interactions. | Users can toggle their vote on a question, which means they can switch from upvoting to downvoting or vice versa. | Proper error handling ensures that issues like missing fields in requests or database errors are managed appropriately, providing a smooth user experience. | . Steps to Achieve This . | Add Upvote and Downvote Functions Implement two functions, addUpvoteToQuestion and addDownvoteToQuestion, in server/models/application.ts to handle upvoting and downvoting of questions. These functions will: . | Check if the question exists. | Add or remove the user’s vote (upvote or downvote) as appropriate. | Update the question’s upvote and downvote counts. | . | Update Routes to Handle Voting Add two new routes, \"/upvoteQuestion\" and \"/downvoteQuestion\", in server/controller/question.ts to handle upvote and downvote requests. These routes will use the newly created functions to update the question’s votes. | Test the Voting Functionality To verify the behavior of the upvote and downvote features, make sure your code passes the tests in application.spec.ts and question.spec.ts files. For your reference, test the following functionalities: . | Successful upvoting and downvoting. | Cancelling an upvote or downvote. | Handling edge cases such as missing parameters in requests. Specifically, ensure the functionality handles scenarios where a user who previously upvoted now intends to downvote. The expected behavior in this case is that the user should be removed from the up_votes array and added to the down_votes array. Additionally, consider the reverse scenario where a user who previously downvoted now intends to upvote. | . Ensure that the code coverage is as thorough as possible for the portions of code you have added or updated as part of this feature. | . Grading for implementation tasks: . | addUpvoteToQuestion and addDownvoteToQuestion: 30 points | Updating routes: 20 points | Testing: 4 points | . ",
    "url": "/CS4530-Fall-2024/assignments/ip1#implementation-tasks",
    
    "relUrl": "/assignments/ip1#implementation-tasks"
  },"20": {
    "doc": "Individual Project 1",
    "title": "Submission Instructions &amp; Grading",
    "content": "You will submit your assignment using GitHub Classroom. This submission will be scored out of 100 points, 90 of which will be awarded for implementation of tasks and accompanying tests, and the remaining 10 for following style guidelines. Testing . You will be provided with starter code that includes a set of tests. Your task is to ensure that all existing tests pass and to create additional tests to cover any new functionality or edge cases. Your code will be evaluated for linting errors and warnings. Submissions that have any linter errors will automatically receive a grade of 0. Do not wait to run the linter until the last minute. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same ESlint configuration that is used by our grading script. Manual Grading . Your code will be manually evaluated for conformance to our course style guide. This manual evaluation will account for 10% of your total grade on this assignment. We will manually evaluate your code for style on the following rubric: . To receive all 10 points: . | All new names (e.g. for local variables, methods, and properties) follow the naming conventions defined in our style guide | There are no unused local variables | All public properties and methods (other than getters, setters, and constructors) are documented with JSDoc-style comments that describe what the property/method does, as defined in our style guide | The code and tests that you write generally follows the design principles discussed in week one. In particular, your design does not have duplicated code that could have been refactored into a shared method. | . We will review your code and note each violation of this rubric. We will deduct two points for each violation, up to a maximum of deducting all 10 style points. Debugging : . If you need help troubleshooting a problem, be sure to follow all the steps outlined in the course’s debugging policy. This will ensure you have exhausted all initial debugging strategies before reaching out for assistance from the TAs. ",
    "url": "/CS4530-Fall-2024/assignments/ip1#submission-instructions--grading",
    
    "relUrl": "/assignments/ip1#submission-instructions--grading"
  },"21": {
    "doc": "Individual Project 1",
    "title": "Individual Project 1",
    "content": "Welcome aboard to the Stack Overflow team! We’re glad that you’re here and ready to join our development team as a new software engineer. We’re building an interactive application for an online community to share their knowledge and experience, and are very happy to see that we have so many new developers who can help make this application a reality. By the end of the semester, you’ll be able to propose, design, implement, and test new features for our project. We understand that some of you may have some web development experience, but don’t expect that most of you do, and hence, we have created an individual project to help you get up to speed with our existing codebase and development environment. FakeStackOverFlow is a web application that consists of some code that runs in each client’s web browser, and also code that runs on a server. This implementation effort will be split across two deliverables. In this first deliverable, you will implement and test the core backend components for this feature, and in the second deliverable, you will implement and test the frontend components. ",
    "url": "/CS4530-Fall-2024/assignments/ip1",
    
    "relUrl": "/assignments/ip1"
  },"22": {
    "doc": "1 - Orientation & Requirements",
    "title": "1 - Orientation & Requirements",
    "content": "Learning Objectives: . In this lecture, you will learn . | a little about the scope of Software Engineering and how it differs from programming | how this course will be organized, and what will be expected from you each week. | two different ways to solicit and document our users’ requirements | . Important Dates: . | Individual Project 1 Due Wednesday, September 18 by 12pm (Noon) | . Lecture Slides: . | Course Introduction Slides PDF, PPT | Requirements Gathering Slides PDF, PPT | . Activity . | Working with User Stories | . Tutorials . | Installing a Development Environment | Getting Started with TypeScript | User Stories and Conditions of Satisfaction | MongoDb tutorial | . Resources . | Class Syllabus | Project Overview | . ",
    "url": "/CS4530-Fall-2024/modules/1-requirements-testing",
    
    "relUrl": "/modules/1-requirements-testing"
  },"23": {
    "doc": "2 - From Requirements to Code",
    "title": "2 - From Requirements to Code",
    "content": "Learning Objectives: . In this lecture, you will learn to: . | Explain the basics of Test-Driven Design | Develop simple applications using Typescript and Jest | Learn more about Typescript and Jest from tutorials, blog posts, and documentation | . Important Dates: . | Individual Project 1 Due Wednesday, September 18 by 12pm (Noon) | . Lecture Slides: . | From Requirements to Code Slides PDF, PPT | . Activity . | TDD Activity Handout | . Tutorials . | Writing Tests with Jest | . Resources . | Podcast: Kent Beck on Software Engineering Daily - An interview with Kent Beck (creator/evangelizer of TDD) about his time at Facebook and the relationship between Facebook and TDD | . ",
    "url": "/CS4530-Fall-2024/modules/2-requirements-to-code",
    
    "relUrl": "/modules/2-requirements-to-code"
  },"24": {
    "doc": "Modules",
    "title": "Modules",
    "content": " ",
    "url": "/CS4530-Fall-2024/modules/",
    
    "relUrl": "/modules/"
  },"25": {
    "doc": "Policies",
    "title": "Grading",
    "content": "There will be individual projects (previously known as assignments) and a team project (in a group of 3-4 members). The overall grading breakdown is: . | 30% Individual project (10% for deliverable 1, 20% for deliverable 2) | 40% Team project (including peer evaluations / surveys) | 10% Participation in synchronous, in-class activities | 20% Exam | . Assignment of team project grades: In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student (which might arise to 100% deduction for not contributing to the project at all). We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluation {during and/or} at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Assignment of final grades: Although each instructor will use the same lesson plans and assignments, we expect that there may be variation in grades when compared between sections. Hence, each instructor will assign final grades to students in their sections, and reserve the right to apply different curves than are used by the other instructors. With each graded assignment, students will be provided with the distribution of all grades in their section. Grading grievances: If you have concerns regarding the grading of your work, please let us know right away by opening a regrade request. All regrade requests must be submitted within 7 days from your receipt of the graded work. If your regrade request is closed and you feel that the response was not satisfactory, you may appeal to the instructor via email within 48 hours. ",
    "url": "/CS4530-Fall-2024/policies/#grading",
    
    "relUrl": "/policies/#grading"
  },"26": {
    "doc": "Policies",
    "title": "Homework policy",
    "content": "Students must work individually on all homework assignments. We encourage you to have high-level discussions with other students in the class about the assignments, however, we require that when you turn in an assignment, it is only your work. That is, copying any part of another student’s assignment is strictly prohibited, and repercussions for doing so will be severe (up to and including failing the class outright). You are free to reuse small snippets of example code found on the Internet (e.g. via StackOverflow) provided that it is attributed. If you are concerned that by reusing and attributing that copied code it may appear that you didn’t complete the assignment yourself, then please raise a discussion with the instructor. Your work is late if it is not turned in by the deadline. | 10% will be deducted for late assignments turned in within 24 hours after the due date. | Assignments submitted more than 24 hours late will receive a zero. | . If you’re worried about being busy around the time of a HW submission, please plan ahead and get started early. Homework that does not compile or run will receive at most 50% credit. For fairness to all, there are no exceptions to the above rules. ",
    "url": "/CS4530-Fall-2024/policies/#homework-policy",
    
    "relUrl": "/policies/#homework-policy"
  },"27": {
    "doc": "Policies",
    "title": "In Class Activities:",
    "content": "Most lectures will feature interactive activities and/or polls that support the material being presented. You must be present in class to participate in the activity or take the poll (participating in an online activity while not attending the synchronous session will be considered academic dishonesty and will be treated harshly). Each instructor may have a different style for assigning participation grades, but historical grading information suggests that each style results in a similar overall grade distribution. Participation grades will be posted on Canvas, and regularly updated. If you join class in person, you are strongly encouraged to bring your laptop or phone to class so that you can participate in the activities. Policy on remote attendance . If you are registered for an on-the-ground section but do not feel comfortable or are unable to attend in person, please contact your instructor in advance of class. We would like to provide the best and most comfortable learning experience, and encourage you to stay at home if advised by a medical professional. ",
    "url": "/CS4530-Fall-2024/policies/#in-class-activities",
    
    "relUrl": "/policies/#in-class-activities"
  },"28": {
    "doc": "Policies",
    "title": "Classroom Environment",
    "content": "To create and preserve a classroom atmosphere that optimizes teaching and learning, all participants share a responsibility in creating a civil and non-disruptive forum for the discussion of ideas. Students are expected to conduct themselves at all times in a manner that does not disrupt teaching or learning. Your comments to others should be constructive and free from harassing statements. You are encouraged to disagree with other students and the instructor, but such disagreements need to respectful and be based upon facts and documentation (rather than prejudices and personalities). The instructors reserve the right to interrupt conversations that deviate from these expectations. Repeated unprofessional or disrespectful conduct may result in a lower grade or more severe consequences. Part of the learning process in this course is respectful engagement of ideas with others. Please don’t be late. You are an essential part of the class. Your participation is an essential part of the class. If you are late, please be courteous to others when entering. BE PRESENT WHEN YOU ARE ATTENDING CLASS. Please do not distract yourself from the class by doing other activities such as phone calls, email, facebook, chat/IM/texting, games, web surfing – unless it has a direct bearing on the course. Then, by all means, surf away! . Attendance in the synchronous meetings is expected. Sometimes you cannot avoid missing a class. If you need to be away from class, it is your responsibility to catch up on the materials discussed in the class. ",
    "url": "/CS4530-Fall-2024/policies/#classroom-environment",
    
    "relUrl": "/policies/#classroom-environment"
  },"29": {
    "doc": "Policies",
    "title": "Academic Integrity",
    "content": "Students must work individually on all homework assignments. We encourage you to have high-level discussions with other students in the class about the assignments, however, we require that when you turn in an assignment, it is only your work. That is, copying any part of another student’s assignment is strictly prohibited. If you steal someone else’s work, you fail the class. You are responsible for protecting your work. If someone uses your work, with or without your permission, you fail the class. You are free to reuse small snippets of example code found on the Internet (e.g., via StackOverflow) provided that it is attributed. Use of co-pilot is also enrouraged. If you are concerned that by reusing and attributing that copied code it may appear that you didn’t complete the assignment yourself, then please raise a discussion with the instructor. If you are in doubt whether using others’ work is allowed, you should assume that it is NOT allowed unless the instructors confirm otherwise. ",
    "url": "/CS4530-Fall-2024/policies/#academic-integrity",
    
    "relUrl": "/policies/#academic-integrity"
  },"30": {
    "doc": "Policies",
    "title": "Accommodations for Disabilities",
    "content": "Students who have disabilities who wish to receive academic services and/or accommodations should visit the Disability Access Services at 20 Dodge Hall or call (617) 373-2675 (previously known as DRC) Please be sure to provide your instructor with DAS’s accommodations letter early in the semester in order to avoid logistical challenges. This course includes a significant group work including project, and providing extensions for group work can be complex. DAS accomodations often do not apply to group submissions but we encourage you to work with your instructors to see how course staff can provide the support you might need. As-per the DAS’s policy, it is the student’s responsibility to coordinate with the instructor in order to request suitable accommodations. ",
    "url": "/CS4530-Fall-2024/policies/#accommodations-for-disabilities",
    
    "relUrl": "/policies/#accommodations-for-disabilities"
  },"31": {
    "doc": "Policies",
    "title": "Title IX Notice",
    "content": "Title IX of the Education Amendments of 1972 protects individuals from sex or gender-based discrimination, including discrimination based on gender-identity, in educational programs and activities that receive federal financial assistance. Northeastern’s Title IX Policy prohibits Prohibited Offenses, which are defined as sexual harassment, sexual assault, relationship or domestic violence, and stalking. The Title IX Policy applies to the entire community, including students, faculty and staff of all gender identities. Faculty members are considered “responsible employees” at Northeastern University, meaning they are required to report all allegations of sex or gender-based discrimination to the Title IX Coordinator. If you or someone you know has been a survivor of a Prohibited Offense, confidential support and guidance can be found through University Health and Counseling Services staff and the Center for Spiritual Dialogue and Service clergy members. By law, those employees are not required to report allegations of sex or gender-based discrimination to the University. Alleged violations can be reported non-confidentially to the Title IX Coordinator within The Office for Gender Equity and Compliance at: titleix@northeastern.edu and/or through NUPD (Emergency 617.373.3333; Non-Emergency 617.373.2121). Reporting Prohibited Offenses to NUPD does NOT commit the victim/affected party to future legal action. In case of an emergency, please call 911. Please visit www.northeastern.edu/ouec for a complete list of reporting options and resources both on- and off-campus. ",
    "url": "/CS4530-Fall-2024/policies/#title-ix-notice",
    
    "relUrl": "/policies/#title-ix-notice"
  },"32": {
    "doc": "Policies",
    "title": "Policies",
    "content": " ",
    "url": "/CS4530-Fall-2024/policies/",
    
    "relUrl": "/policies/"
  },"33": {
    "doc": "Project Overview",
    "title": "Project Overview",
    "content": "The individual and team project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement new features. The codebase that we’ll be developing on is a Fake Stack Overflow project (let’s call it HuskyFlow). You will get an opportunity to work with the starter code which provides basic skeleton for the app and then additional features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. Overview of Project Deliverables . | Date | Deliverable | Description | . | 09/27/2024 | Team Formation Survey | Specify preferences for teammates | . | 10/02/2024 | Project Kick-off Meeting | Schedule a meeting with your Mentor TA during this week | . | 10/09/2024 | Preliminary Project Plan | Propose a new feature for StackOverflow project that can be planned and implemented within 7 weeks | . | 10/23/2024 | Revised Project Plan | Refine the scope of your feature based on staff feedback, define detailed requirements and project acceptance criteria. | . | 11/26/2024 | Project Delivery - Implementation and Documentation | Deliver/Deploy your new features, including design documentation and tests | . Summary of Project Grading . Your overall project grade (which will account for 40% of your final grade in this course) will be the weighted average of each of the deliverables. | Planning (20%) . | This includes the Preliminary Project Plan and the Revised Project Plan. | . | Process (20%) . | This includes: use of a structured development process, including regular git commits, code reviews, timely completion of progress reports and individual/team surveys, and weekly meetings with TA Mentor. | This also includes appropriate division of labor within the project (i.e., roughly equal). For full credit, each member of the team must have at least 4 commits in the final delivered code. | . | Product (40%) . | 20% Successful delivery of your Minimum Viable Product as defined in your project plan | 10% Desirable delivered features | 10% Test suite of your features. | . | Reports (20%) . | 10% Final Report | 10% Poster and Demo | . | . In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student (which might arise to 100% deduction for not contributing to the project at all). We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluations (during and/or at the end of the project). We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Team Formation . All projects will be completed in a team of 3-4 students. The very first deliverable for the project will be a team formation survey: you will be able to indicate your preferences for teammates. The instructors will assign students to the teams based on a number of factors including your responses to the survey and diversity of skills for the teammates. All students in each team MUST be in the same section of the class. Team Meetings with TA Mentor . Each team will be assigned a TA to act as a mentor, who will work closely with you for the entire project and also will serve as your point of contact for project questions and grading. During Week 5, you will arrange a “Kickoff Meeting” with your TA mentor, where you will meet your TA mentor and have the opportunity to share any early ideas that you might want feedback on before submitting the your preliminary project plan. Once project begins in full force, you will have weekly meetings with your TA mentor (scheduled at your team’s and the TA’s convenience) in order to help ensure that you are making progress on the project, and to help address problems that you encounter (be they technical or non-technical problems). Preliminary Project Plan . All projects will involve frontend and backend development of new features for FakeStackoverflow. Once teams have been formed, you and your team will decide what kind of new features you would like to build. Your features should be something that can be implemented within the timeframe allotted (5-7 weeks), and will be implemented in a fork of the main codebase. Given that you will be up-to-speed on the project codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of three or four, we expect that the feature that you propose will be more complex than the feature implemented in the individual projects. The project plan will focus on two sections: . | User stories and conditions of satisfaction that describe the features that you plan to implement. EACH CONDITION OF SATISFACTION MUST HAVE A PRIORITY (Essential, Desirable, or Optional). The set of essential items will constitute the “Minimum Viable Product” discussed above. | Work breakdown: Map your user stories to engineering tasks. Assign each task to a team member (or pair of team members), provide an estimate for how long each task will take, a brief rationale for that estimate, and schedule those stories into sprints. | . Creating a GitHub Repository . Your team’s development must take place within a GitHub repository in our GitHub Classroom. This repository will be private, and visible only to your team and the course staff. After the semester ends, you are welcome to make it public - you will have complete administrative control of the repository. We will provide instructions to set up these repositories for all groups and will also provide the starter code for the project (after the revised project plans are submitted). Revised Project Plan . Based on the feedback that you receive from the course staff, you will revise your preliminary project plan, creating a more detailed plan to implement your new feature. The project plan will include: . | Revised user stories and conditions of satisfaction (based on feedback on the preliminary project plan) | Revised work breakdown (based on feedback on the preliminary project plan) | . Your team will self-organize, as agile teams do, and will use the work breakdown and schedule as the basis for weekly check-ins with your team’s TA. Software Development Process . Each team is expected to use of a structured development process, including use of pull requests and code reviews for their regular github commits. You will also need to ensure appropriate division of labor within the project (i.e., roughly equal). Teams will also be expected to complete regular progress reports (or sprint retrospectives), and individual/team surveys. Peer evaluation may also be used (for Week 6, 8-13). Please note that one of the most important factors in successfully completing a team project is having effective communication between all team members and stakeholders. Project Implementation and Documentation . Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Your final team deliverable will include: . | The implementation of your new features | Automated tests for your new features | A Final Report | A Poster &amp; Demo (each instructor will provide specifics of the demo, which might vary for each section) | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own, which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any procesess that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . The details for the final project deliverable and associated rubrics will be released by Week 10. ",
    "url": "/CS4530-Fall-2024/assignments/project-overview",
    
    "relUrl": "/assignments/project-overview"
  },"34": {
    "doc": "Other Resources",
    "title": "Other Resources",
    "content": "There are many articles, blogs, books and podcasts that are very interesting for more reading on the topics discussed in class. We’ll update this list as the semester goes, and if you have suggestions of materials to share, please let us know and we’ll add it to the list. Podcasts . The Software Engineering Radio podcast (also available wherever you get your podcasts) aims to produce educational material for professional softare developers, and includes conversations between experts and researchers on various software engineering topics. Here are a few of our favorites that are most relevant to topics that we cover in this class: . | Donny Nadolny on Debugging Distributed Systems, with Robert Blumen, 2017 | Jafar Soltani on Continuous Delivery for Multiplayer Games, with Nate Black, 2018 | Chris Richardson on Microservice Patterns, with Robert Blumen, 2019 | Margaret Burnett on Gender, Cognitive Styles and Usability Bugs, with Felienne Hermans, 2019 | Michaela Greiler on Code Reviews, with Felienne Hermans, 2020 | Ipek Ozkaya on Managing Technical Debt, 2021 | . Code style . | Research paper: To camelcase or under_score, Dave Binkley et al | Research paper: I know what you did last summer: an investigation of how developers spend their time, Minelli, Mocci and Lanza | Research paper: A metric for software readability, Buse and Weimer | Book (free via library): “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | . Debugging . | Book (free via library): “Effective Debugging: 66 Specific Ways to Debug Software and Systems” by Diomidis SpinellisA helpful guidebook for debugging, laying out different strategies that are effective for testing different kinds of debugging hypotheses. | . Design Patterns . | Book (free via library): “Design Patterns Explained: A New Perspective on Object-Oriented Design” by Alan Shalloway and James TrottIn-depth coverage of design patterns, considering why they are important in software development, how to apply them, and descriptions of some common patterns. | Book (free via library): “Refactoring to Patterns” by Joshua KerievskyA unification of the classic Gang of Four Design Patterns work with Fowler’s refactoring work, with practical example of how to introduce patterns into existing code bases to improve code quality. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | . Infrastructure + Operations . | Book (free via library) “Site Reliability Engineering” By Betsy Beyer, Chris Jones, Niall Richard Murphy, Jennifer Petoff Site Reliability Engineering is a topic very related to software engineering: while software engineers might focus primarily on the design and development of software systems, SRE’s are engineers who focus on the deployment, monitoring and maintenance of that software. This book documents the SRE practices at Google. | . JavaScript . | Book (free via library): “Modern JavaScript for the Impatient” by Cay Horstmann | . Program Understanding . | Book: “The Programmer’s Brain” by Felienne Hermans A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | . ",
    "url": "/CS4530-Fall-2024/resources/",
    
    "relUrl": "/resources/"
  },"35": {
    "doc": "Section 1 - Calendar",
    "title": "Section 1 - Calendar",
    "content": " ",
    "url": "/CS4530-Fall-2024/calendar/s1",
    
    "relUrl": "/calendar/s1"
  },"36": {
    "doc": "Section 2 - Calendar",
    "title": "Section 2 - Calendar",
    "content": " ",
    "url": "/CS4530-Fall-2024/calendar/s2",
    
    "relUrl": "/calendar/s2"
  },"37": {
    "doc": "Section 5 - Calendar",
    "title": "Section 5 - Calendar",
    "content": " ",
    "url": "/CS4530-Fall-2024/calendar/s5",
    
    "relUrl": "/calendar/s5"
  },"38": {
    "doc": "Section 8 - Calendar",
    "title": "Section 8 - Calendar",
    "content": " ",
    "url": "/CS4530-Fall-2024/calendar/s8",
    
    "relUrl": "/calendar/s8"
  },"39": {
    "doc": "Section 9 - Calendar",
    "title": "Section 9 - Calendar",
    "content": " ",
    "url": "/CS4530-Fall-2024/calendar/s9",
    
    "relUrl": "/calendar/s9"
  },"40": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": "Given the synchronization amongst the sections, and the academic calendar starting on a Wednesday, the course material generally is designed to run on weeks from Wednesday-Tuesday. We provide a schedule for each section: . ",
    "url": "/CS4530-Fall-2024/calendar/",
    
    "relUrl": "/calendar/"
  },"41": {
    "doc": "Staff",
    "title": "Staff",
    "content": "For technical questions related to the codebase, please check piazza first (or post a query there). For discussing the course material or the individual projects, please feel free to attend whichever TA’s office hours are convenient. For project-related questions, please coordinate a time to chat directly with your assigned project mentor. ",
    "url": "/CS4530-Fall-2024/staff/",
    
    "relUrl": "/staff/"
  },"42": {
    "doc": "Staff",
    "title": "Office Hours",
    "content": "All TA office hours will be held virtually. We will explore the options of holding in-person office hours too, subject to interest from students/TAs and availability of a room. Instructor office hours may be held in-person or remotely. TA Office Hours are hosted on Microsoft Teams, using the Khoury Office Hours app. Please see the user guide for information on how to log in and ask questions. ",
    "url": "/CS4530-Fall-2024/staff/#office-hours",
    
    "relUrl": "/staff/#office-hours"
  },"43": {
    "doc": "Staff",
    "title": "Schedule",
    "content": " ",
    "url": "/CS4530-Fall-2024/staff/#schedule",
    
    "relUrl": "/staff/#schedule"
  },"44": {
    "doc": "Staff",
    "title": "Instructors",
    "content": "Adeel Bhutta . a.bhutta@northeastern.edu . Section: CS4530 Sections 1, 2, 5 &amp; 8 . Office Hours: . | In-Person: Tuesdays and Thursdays 140pm - 230pm, Meserve 337 | or Book an appointment with me for a Virtual meeting | . Mitch Wand . wand@ccs.neu.edu . Section: CS4530 Section 9 . Office Hours: . | on Zoom, directly following class | . ",
    "url": "/CS4530-Fall-2024/staff/#instructors",
    
    "relUrl": "/staff/#instructors"
  },"45": {
    "doc": "Staff",
    "title": "Teaching Assistants",
    "content": "Anikesh Ganesh Kamath . kamath.ani@northeastern.edu . Aryan Jain . jain.aryan@northeastern.edu . Bhupesh Digambar Patil . patil.bhu@northeastern.edu . Harikrishnan Unnikrishna Pillai . unnikrishnapillai.h@northeastern.edu . Hongyi Zhang . zhang.hongyi@northeastern.edu . Ngoc Khanh Vy Le . le.ngoc@northeastern.edu . Nishy Ann Tomy . tomy.ni@northeastern.edu . Rumjhum Singru . singru.r@northeastern.edu . Samuel Tomlinson . tomlinson.sa@northeastern.edu . Sanjana Poojary . poojary.sa@northeastern.edu . Sharan Parikh . parikh.shar@northeastern.edu . Srinivasa Pavan Kumar Danaboina . danaboina.s@northeastern.edu . Vatsal Mehta . mehta.vats@northeastern.edu . Vihar Gunamgari . gunamgari.s@northeastern.edu . ",
    "url": "/CS4530-Fall-2024/staff/#teaching-assistants",
    
    "relUrl": "/staff/#teaching-assistants"
  },"46": {
    "doc": "Code Style",
    "title": "Code Style",
    "content": "Programs are easier to read and to understand when they are written in a familiar style and follow standard coding conventions. Most organizations that develop software therefore require programmers to write programs that follow the organization’s preferred style and coding conventions. These conventions can be very elaborate. Many of the guidelines are, in fact, arbitrary. When you are working on a coding project with other developers, different developers often have preference for slightly different syntax, for instance: should our string literals be enclosed by single quotes (') or double quotes (\")? Should files be indented with spaces or tabs? In TypeScript, there are often multiple ways to accomplish the same goal, for instance, you could create a new empty array with the expression const myArray = new Array(), or const myArray = []. Sometimes there is no difference between these variants except for how it reads, and other times there may be unintended consequences of making the seemingly correct but subtly wrong choice. Thankfully, it is possible to write automated checkers (and, at times, fixers) for these style violations. All code that you write for this class will be checked by ESLint, and must be free of style warnings and errors. Our ESlint rules are derived from Airbnb’s JavaScript Style Guide, ESLint’s Recommended Rules, TypeScript/ESLint Recommended Rules, React ESLint Rules and React Hooks ESLint Rules. We do not suggest studying these lists directly, instead, begin writing code naturally, and allow your IDE’s built-in style checker to report issues as you find them. The most important rules to get started are: . | Indent using spaces, not tabs; use 2 spaces for each level of indentation | Enclose all string literals with single quotes, not double | Variables must be named using lowerCamelCase, types are named using UpperCamelCase. Constants (read-only variables that are assigned a static value once and not reused) must be named using UPPER_CASE_WITH_UNDERSCORES. | The maximum line length is 100 characters | . Naming . While the linter can automatically flag names that violate camelCase rules, it can not automatically determine that a name is “good” - this is a subjective judgement call. Please consider the following when choosing names: . | Names should be informative (e.g lineTooLong() rather than checkLineLength()) | Names for types are typically nouns or noun phrases. Interface names, however, might be adjectives (e.g. Serializable). Class names may be noun phrases that include the interface name (e.g. CuckooClock and DigitalClock for classes that implement the interface Clock). | Use noun-like names for functions or methods that return values (e.g. circleDiameter rather than calculateDiameter). (Exception: simple getters can still have names that begin with get). | Reserve verb-like names for functions that perform actions (e.g. addItem). | Use adjective phrases for predicates when possible (e.g. line.tooLong()) | Variable and property names should be descriptive of what the variable is for, and not be named after the type of the variable (which is captured in the variable’s type declaration) | Names for properties that are private must start with a _ | . Documentation and Comments . All public properties and methods (other than getters, setters, and constructors) must be documented using JSDoc-style comments that describes what the property/method does. Example: . /** The unique identifier for this player * */ private readonly _id: string; . /** * A handler to process a remote player's subscription to updates for a room * * @param socket the Socket object that we will use to communicate with the player */ . Consider adding comments within your code to describe non-obvious behavior, or to capture why the code is written the way that it is. Do not add comments that simply restate what can already be immediately discerned by reading the code. For example, here is a useful comment: . // No valid session exists for this token, hence this client's connection should be terminated socket.disconnect(true); return; . Here is a useless comment on the same code snippet: . // Disconnect the socket socket.disconnect(true); return; . Comments are for documentation, not for keeping track of old code you are no longer using (do not submit commented-out code). ",
    "url": "/CS4530-Fall-2024/policies/style/",
    
    "relUrl": "/policies/style/"
  },"47": {
    "doc": "Textbooks",
    "title": "Textbooks",
    "content": "This class is a survey of many sub-areas of software engineering, and an unfortunate result of this is that there is no single textbook that is appropriate for this class. However, there are several texts that have chapters that are quite relevant, and most of these books are available for free for Northeastern students through O’Reilly’s Safari Books online. To create your account, first visit this page: https://www.safaribooksonline.com/library/view/temporary-access/ and then select “Not Listed? Click Here” for institution, then enter your @northeastern.edu email address. After this first account creation, you’ll be able to log in directly to Safari Books Online with your @northeastern.edu email and no need for 2FA (hooray!). The schedule will list which chapters of which texts are relevant for each lecture: . | “Software Engineering at Google” By Titus Winters, Tom Manshreck and Hyrum Wright This book is effectively a manual that describes the software engineering practices at Google, and the rationale behind those practices | “Effective Software Testing: A Developer’s Guide” by Mauricio Aniche (Not on Safari) A focused discussion of software testing concepts, with concrete examples using popular Java testing frameworks. | “The Programmer’s Brain” by Felienne Hermans (Not on Safari) A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | “Learn React with TypeScript 3” by Carl RipponA solid reference for React, describing how to get started, plus more advanced features like React’s Router and testing using Jest | “Programming TypeScript” by Boris ChernyA useful introduction to TypeScript, written assuming familiarity with programming in languages like Java, C# or python. | . ",
    "url": "/CS4530-Fall-2024/textbooks/",
    
    "relUrl": "/textbooks/"
  },"48": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/CS4530-Fall-2024/tutorials/",
    
    "relUrl": "/tutorials/"
  },"49": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS",
    "content": "Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. For this class, you will need Node.js version 20 (20.17.0 was the latest version at time of writing, although any 20.x should work in theory). There are many ways that you can install Node.js: for instance, you can use a package manager like snap or homebrew to install it; you can download an installer directly from the Node.js website, and you can, of course, build it from source. However, due to the complexity of running different Node.js versions on the same machine, we very strongly suggest using nvm, as explained below. We recommend installing Node.js using nvm, the node version manager. When language runtimes are in active development (like Node.js is), sometimes you end up needing to have multiple versions of Node.js installed, and different projects that you work on might require different versions of Node.js. These annoyances are quite rare, but when it happens that you need to have mutliple versions of Node.js installed, it’s super handy to have your system set up already so that installing multiple versions and switching between it is easy. You can use our instructions to set up nvm even if you have previously installed Node.js. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installing-nodejs",
    
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs"
  },"50": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS with NVM for Windows",
    "content": "Before starting the installation, make sure to kill your Visual Studio Code if you have it installed. To do that on Windows, open a command prompt(type cmd in the windows start bar, then select “Run as administrator”) and run the command taskkill.exe /IM code.exe. | Download nvm-setup.zip from the most recent release of nvm-windows (at time of writing this document, version was 1.1.12). | . | Extract the contents of nvm-setup.zip and run the executable nvm-setup.exe. | This should open the nvm installation wizard. | . | Accept the license agreement and click next. Continue to accept the default choices for any remaining prompts, and click “install”. If you receive messages along the lines of “NodeJS version XYZ is already installed, would you like nvm to control this installation,” select “Yes”. | Upon completion, you will see the below window . | . | Open a command prompt with administrative privileges (type cmd in the windows start bar, then select “Run as administrator”). | Verify the installation, run the command nvm version . | This should display the version of nvm installed. | | . | Install Node.js version 20 using the command nvm install 20. | To use this version of NodeJS, run the command nvm use 20. | . | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows",
    
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows"
  },"51": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Linux / Mac)",
    "content": ". | Run either curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash or If wget is installed then run wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash. | Close and reopen the active terminal. Note: You can also restart your terminal by running source ~/.bashrc or source ~/.zshrc depending on your shell. | Verify nvm is working by entering command -v nvm. If your terminal prints out nvm, it should be working. If you see nvm: command not found or no feedback, open a new terminal and trying again or restart from step 1. | Install the required version of Node.js by typing nvm install 20. | . Installing NVM when using the fish terminal (Linux / Mac) . Note: When using the Fish terminal, nvm.fish should be used to install nvm. This is not a fish wrapper for nvm rather it is written from scratch using fish. Current version of NVM is not supported on terminals that are running fish or have installed fish in the past. | Install nvm.fish using Fisher: fisher install jorgebucaran/nvm.fish | Restart fish by entering fish in your active terminal | Verify nvm is working by entering nvm -v | Install the required version of Node.js by typing nvm install 20. | . Working with MacOS M1 Silicon: If you have macOS on M1 Silicon 2022, you can find instructions here. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installation-steps-linux--mac",
    
    "relUrl": "/tutorials/week1-getting-started#installation-steps-linux--mac"
  },"52": {
    "doc": "Installing a Development Environment",
    "title": "Verification",
    "content": ". | Open a shell (for Linux / Mac) or windows powershell/command prompt (for Windows). | Run the command node -v . | This should print the current version of nodeJS installed (20.x.x). | . | Run the command npm -v . | This should print the current version of npm installed (v10.x.x). | | . | If you find that some other version is being used, run the command nvm use 20. For Linux / Mac, you can change the default to 20 by running the command nvm alias default 20. | . Note: The alias command is not compatible with nvm.fish. Instead, you can add a default version with the command exec nvm use 20 in your ~/.config/fish/config.fish file. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#verification",
    
    "relUrl": "/tutorials/week1-getting-started#verification"
  },"53": {
    "doc": "Installing a Development Environment",
    "title": "Installing Visual Studio Code (VSCode)",
    "content": "Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). VSCode also supports importing hotkey configurations from most other text editors and IDEs. Read more here. While you are required to use an IDE for this class, it is not mandatory to use VSCode: if you already are comfortable developing TypeScript or JavaScript in another suitable IDE (like IntelliJ), then you are welcome to continue to use that. However, VSCode is the “supported” option: if you struggle to get things like the linter set up correctly in VSCode, we will be happy to help you. However, we can’t provide such support for all IDEs. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installing-visual-studio-code-vscode",
    
    "relUrl": "/tutorials/week1-getting-started#installing-visual-studio-code-vscode"
  },"54": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | Administrative access on the host machine for software installation. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#pre-requisites",
    
    "relUrl": "/tutorials/week1-getting-started#pre-requisites"
  },"55": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Windows / Mac)",
    "content": ". | Download the VSCode installer from the VSCode website. | . | Run the installer to start the installation wizard for VSCode . | . | Accept the license agreement and click next. | . | Choose the installation directory of your choice and click next. | . | Click next on the select start menu folder screen. | . | Tick all check boxes on the select additional tasks menu and click next. | . | Review the settings on the the “Ready to install” screen and click Install to begin installation. | Once the installation is complete, you will see the below screen and you are ready to use VSCode. | . | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installation-steps-windows--mac",
    
    "relUrl": "/tutorials/week1-getting-started#installation-steps-windows--mac"
  },"56": {
    "doc": "Installing a Development Environment",
    "title": "Installation (Linux)",
    "content": ". | The above instructions for Windows/Mac should also work, but VSCode is also provided as a snap package | . | Install snap if you haven’t already by running sudo apt update and then sudo apt install snapd. | Install VSCode by running sudo snap install --classic code. | Open VSCode as an application on your desktop. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installation-linux",
    
    "relUrl": "/tutorials/week1-getting-started#installation-linux"
  },"57": {
    "doc": "Installing a Development Environment",
    "title": "Additional Extensions (Optional)",
    "content": "VSCode comes with a rich set of extensions to aid in software development. Below is a list of extensions that you may find useful. | GitLens - Git Supercharged | Prettier - code formatter | vscode-icons | ESLint | Andromeda (Color theme: Andromeda Colorizer) | Jest Runner (highly recommended) | GitHub Copilot and GitHub Copilot Chat | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#additional-extensions-optional",
    
    "relUrl": "/tutorials/week1-getting-started#additional-extensions-optional"
  },"58": {
    "doc": "Installing a Development Environment",
    "title": "Installing Extensions (eg. ESLint)",
    "content": ". | Click on the extensions tab on the left in VSCode. | Search ESLint. | Click on Install. | Done! . | . | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#installing-extensions-eg-eslint",
    
    "relUrl": "/tutorials/week1-getting-started#installing-extensions-eg-eslint"
  },"59": {
    "doc": "Installing a Development Environment",
    "title": "Additional Settings (Optional)",
    "content": "You may find it useful to add some settings: . | Turn on “bracket pair colorization” (in File &gt; Preferences &gt; Settings) | Add a keybinding for formatting the current selection (in File &gt; Preferences &gt; Keyboard Shortcuts &gt; Format Selection ) | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#additional-settings-optional",
    
    "relUrl": "/tutorials/week1-getting-started#additional-settings-optional"
  },"60": {
    "doc": "Installing a Development Environment",
    "title": "Getting Started With Typescript",
    "content": "Typescript is a superscript of JavaScript which adds type information and other features. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#getting-started-with-typescript",
    
    "relUrl": "/tutorials/week1-getting-started#getting-started-with-typescript"
  },"61": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | NodeJS | VSCode (recommended but not required) | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#pre-requisites-1",
    
    "relUrl": "/tutorials/week1-getting-started#pre-requisites-1"
  },"62": {
    "doc": "Installing a Development Environment",
    "title": "Hello World",
    "content": ". | Create a new directory and open it with VSCode. | Create a new file called hello-world.ts. | You can do this from within VSC by typing ctrl + N, but this is not necessary. | . | Add the following code to the file: console.log('Hello, World!'); . | Open the terminal with ctrl + ~ or ctrl + ‘`’ (ctrl-backtick) . | Ensure that you are in the same directory as hello-world.ts. | . | Install typescript by running the command npm install --save typescript . | This will install Typescript locally in the current directory. | . | Run the command npx ts-node hello-world.ts. | If you are prompted, enter y. | This will give the result below. | | . | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started#hello-world",
    
    "relUrl": "/tutorials/week1-getting-started#hello-world"
  },"63": {
    "doc": "Installing a Development Environment",
    "title": "Installing a Development Environment",
    "content": "This tutorial describes the basic steps needed to set up a development environment with NodeJS, TypeScript, and VisualStudio Code. At the end of this tutorial, you should have a complete local development environment that you can use to build and test code for this class. Contents: . | Installing NodeJS | Installing Visual Studio Code | Hello, World in TypeScript | . If you run into any difficulties following any of these steps, please post (in a non-private question) on Piazza. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-getting-started",
    
    "relUrl": "/tutorials/week1-getting-started"
  },"64": {
    "doc": "MongoDB and Mongoose",
    "title": "A mini-tutorial on MongoDB and Mongoose",
    "content": "This tutorial provides basic introduction to MondoDB and Mongoose: . Contents: . | MongoDB Concepts | Mongoose representation of MongoDB Concepts | Databases, Collections, and Documents | ObjectIDs and References | Queries | Examples | Resources | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-mongodb-mongoose#a-mini-tutorial-on-mongodb-and-mongoose",
    
    "relUrl": "/tutorials/week1-mongodb-mongoose#a-mini-tutorial-on-mongodb-and-mongoose"
  },"65": {
    "doc": "MongoDB and Mongoose",
    "title": "MongoDB Concepts",
    "content": ". | An installation consists of a set of named databases. | A database consists of a set of named collections. | A collection consists of a set of documents. | A document is a set of (property,value) pairs. | A schema is a set of (property,type) pairs. All of the documents in a single collection should satisfy the same schema. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-mongodb-mongoose#mongodb-concepts",
    
    "relUrl": "/tutorials/week1-mongodb-mongoose#mongodb-concepts"
  },"66": {
    "doc": "MongoDB and Mongoose",
    "title": "Mongoose representation of MongoDB Concepts",
    "content": "Databases, Collections, and Documents . Mongoose provides representations of MongoDB concepts in the TypeScript/JavaScript language. | In any given program mongoose refers to a particular database in a particular MongoDB instance. For example, executing | . await mongoose.connect(\"mongodb://127.0.0.1:27017/pets\"); . causes mongoose to refer to the pets database in the local MongoDB instance. | A MongoDB schema is represented in Mongoose by an object of class mongoose.Schema. For example, executing | . const kittySchema = new mongoose.Schema({ name: String, color: String, }); . causes kittySchema to represent a Mongo schema with a single property, name, of type String. References to other documents are represented by properties with type Types.ObjectID (more on this later) . In this document, we will use the terms ‘property’ and ‘field’ interchangeably. | A MongoDB collection of documents is represented in Mongoose by a TypeScript constructor created by mongoose.model. For example | . const Kitten = mongoose.model(\"Kitten\", kittySchema); . causes Kitten to refer to a collection named ‘Kitten’ in the current instance; all the documents in the Kitten collection should satisfy the schema represented by kittySchema. | A document with schema M is represented by a TypeScript object created by saying new C, where C is constructor created by mongoose.model. For example | . const fluffy = new Kitten({ name: \"fluffy\", color: \"black\" }); . creates a document intended for insertion in the collection named Kitten. | In Mongoose, creation of a document is separate from being inserted in a collection. So to actually insert fluffy in the Kitten collection, we need to execute | . await fluffy.save(); . Note that most of the operations that touch the database are asyncs. ObjectIDs and References . In MongoDB, every document has a unique identifier, which is kept in its _id field. Queries . In Mongoose, a query is a recipe for retrieving documents from a collection. There are lots of ways to do this. Here are some that work (for a collection called Dogs) . Dog.find(); // finds all documents in the `Dog` collection Dog.findOne({ name: \"Buddy\" }); // finds one of the dogs named 'Buddy' Dog.find({ breed: \"Labrador\" }); // finds all dogs of the given breed . These are all asyncs, so you need to await them. The query syntax offers lots of methods for selecting, sorting, etc. Take a look at this example, which two very different ways of writing the same query: . // With a JSON doc Person.find({ occupation: /host/, \"name.last\": \"Ghost\", age: { $gt: 17, $lt: 66 }, likes: { $in: [\"vaporizing\", \"talking\"] }, }) .limit(10) .sort({ occupation: -1 }) .select({ name: 1, occupation: 1 }) .exec(callback); // Using query builder Person.find({ occupation: /host/ }) .where(\"name.last\") .equals(\"Ghost\") .where(\"age\") .gt(17) .lt(66) .where(\"likes\") .in([\"vaporizing\", \"talking\"]) .limit(10) .sort(\"-occupation\") .select(\"name occupation\") .exec(callback); . For small projects like the one in the course, it is probably preferable to use the simplest Mongoose queries you can, and then process the list of documents that the query returns. There are some circumstances where it is helpful to the query do more work. Consider, for example, the following excerpt from models/application.ts . const q = await QuestionModel.findOneAndUpdate( { _id: new ObjectId(qid) }, { $inc: { views: 1 } }, { new: true } ).populate({ path: \"answers\", model: AnswerModel }); return q; . Here we are give an objectID qid. The call to .findOneAndUpdate first finds a document whose _id field matches qid. It then calls the document’s $inc method to increment its views field by 1. The default behavior of findOneAndUpdate is to return the original (unmodified) document. But that’s not what we wanted here, so we add a third argument { new: true } to return the updated document. All that would be hard to do except by making it part of findOneAndUpdate. Examples . A simple example (i.e, example.ts) can be accessed here. Resources . | Official Mongoose/TypeScript docs | Mongoose Queries | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-mongodb-mongoose#mongoose-representation-of-mongodb-concepts",
    
    "relUrl": "/tutorials/week1-mongodb-mongoose#mongoose-representation-of-mongodb-concepts"
  },"67": {
    "doc": "MongoDB and Mongoose",
    "title": "MongoDB and Mongoose",
    "content": " ",
    "url": "/CS4530-Fall-2024/tutorials/week1-mongodb-mongoose",
    
    "relUrl": "/tutorials/week1-mongodb-mongoose"
  },"68": {
    "doc": "Typescript Basics",
    "title": "Typescript Basics",
    "content": "This tutorial describes the basic concepts and syntax of typescript with code examples. Typescript is treated here as an extension of JavaScript, but it requires no prior knowledge to follow along. You can run the examples on Online Typescript Editor . Contents: . | Types in Typescript . | Boolean | Number | BigInt | String | Arrays | Tuples | Enums | Any | Unknown | Literal | . | Variable declaration in typescript | Objects | Control Flow Statements . | Equality vs Strict Equality | . | Loops | Array Functions . | ForEach | Map | Filter | Reduce | . | Functions . | Typing the function | Invoking the function | Optional and Default Parameters | Rest Parameters | Functions as Constructors | Arrow Functions | Function Overloads | . | Classes . | Creating a class | Creating an abstract class | . | Type Aliases | Interfaces | Custom types | Generics | Modules | Object oriented programming concepts using typescript . | Inheritance | Polymorphism | Abstraction | Encapsulation | . | General Guidelines | tsconfig | . Typescript is a superset of JavaScript. Thus, all JavaScript code is valid Typescript code. Typescript introduces concepts of optional typing, modules, and few additional features to Javascript. Let us begin by extending JavaScript to use the features of Typescript and primitive types. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics",
    
    "relUrl": "/tutorials/week1-typescript-basics"
  },"69": {
    "doc": "Typescript Basics",
    "title": "Types in typescript",
    "content": "Boolean . The boolean type has two values: true and false. Example: . let a = true // boolean var b = false // boolean const c = true // true let d: boolean = true // boolean let e: true = true // true . | Usage: You can compare them (with ==, ===, ||, &amp;&amp;, and ?), negate them (with !). | . Number . Number is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN. Example: . var b = Infinity * 0.10 // number const c = 5678 // 5678 let d = a &lt; b // boolean let e: number = 100 // number let f: 26.218 = 26.218 . | Usage: Numbers can do things, like addition (+), subtraction (-), modulo (%), and comparison (&lt;). When working with long numbers, use numeric separators to make those numbers easier to read. | . BigInt . The bigint type is the set of all BigInts, and supports things like addition (+), subtraction (-), multiplication (*), division (/), and comparison (&lt;). Example: . let a = 1234n // bigint const b = 5678n // 5678n var c = a + b // bigint let d = a &lt; 1235 // boolean let e = 88.5n // Error TS1353: A bigint literal must be an integer. let f: bigint = 100n // bigint let g: 100n = 100n . | Usage: It lets you work with large integers without running into rounding errors. While the number type can only represent whole numbers it can hold numbers larger than 253 – 1. | . String . String is the set of all strings and the things you can do with them like concatenate (+), slice (.slice),etc. Example: . let a: string = 'hello' // string let b: string = 'world' // string let c: string = a + ' ' + b // string . | Usage: Any functionality that requires the functionality of a string of characters. Here are a couple of string operations: | . charAt() : This method returns the character from the specified index. Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string, called stringName, is stringName.length – 1. Syntax: . string.charAt(index) . slice() : This method extracts a section of a string and returns a new string. Syntax: . string.slice( beginSlice [, endSlice]) . split() : This method splits a String object into an array of strings by separating the string into substrings. Syntax: . string.split([separator][, limit]) . concat(): This method adds two or more strings and returns a new single string. Syntax: . string.concat(string2, string3[, ..., stringN]) . indexOf(): This method returns the index within the calling String object of the first occurrence of the specified value, starting the search at index or -1 if the value is not found. Syntax: . string.indexOf(searchValue[, fromIndex]) . Arrays . Like in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing. Arrays are iterable Objects with the keys as numbers. Example: . let a = [1, 2, 3] // number[] var b = ['a', 'b'] // string[] let c: string[] = ['a'] // string[] let d = [1, 'a'] // (string | number)[] const e = [2, 'b'] // (string | number)[] let f = ['red'] f.push('blue') let g = [] // any[] g.push(1) // number[] g.push('red') // (string | number)[] let h: number[] = [] // number[] h.push(1) // number[] . Tuples . Tuples are subtypes of array. They’re a special way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them. Example: . let a: [number] = [1] // A tuple of [first name, last name, birth year] let b: [string, string, number] = ['malcolm', 'gladwell', 1963] . | Usage: In TypeScript Tuples support optional elements too. Just like in object types, ? means “optional”. Tuples also support rest elements, which you can use to type tuples with minimum lengths. Not only do tuple types safely encode heterogeneous lists, but they also capture the length of the list they type. | . Enums . Enums are a way to enumerate the possible values for a type. They are unordered data structures that map keys to values. Example: . enum Language { English, Spanish, Russian } . | Usage: There are two kinds of enums: enums that map from strings to strings, and enums that map from strings to numbers. Use it when you wish to provide flexibility making it easier to express and document intentions and use cases or when you want to save compile-time and runtime with inline code. | . Any . The any data type is the super type of all types in TypeScript. It denotes a dynamic type. Using the any type is equivalent to opting out of type checking for a variable. Example: . let a: any = 666 // any let b: any = ['danger'] // any let c = a + b // any . | Usage: In TypeScript everything needs to have a type at compile time, and any is the default type when you (the programmer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. | . Unknown . If any is the Godfather, then unknown is Keanu Reeves as undercover FBI agent Johnny Utah in Point Break: laid back, fits right in with the bad guys, but deep down has a respect for the law and is on the side of the good guys. You can compare unknown values (with ==, ===, &amp;&amp;, and ?), and refine them (like you can any other type) with JavaScript’s typeof and instanceof operators. Example: . let a: unknown = 30 // unknown let b = a === 123 // boolean . | Usage: For the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. | . Literal . In addition to standard types like boolean or number, TypeScript also supports literal types. A literal type represents a specific value, not just a general type. Example: . let e: true = true; // This is a literal type, constrained to the value true. let count: 10 = 10; // This can only ever be the number 10. let status: \"pass\" = \"pass\"; // This can only ever be the string \"pass\". These types act like constants and can only have one exact value, adding stricter type safety to your code. If you try to modify them an error will be thrown. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#types-in-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#types-in-typescript"
  },"70": {
    "doc": "Typescript Basics",
    "title": "Variable declaration in typescript",
    "content": "Variables can be declared in Typescript using one of 3 keywords: . | var: var declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this var-scoping or function-scoping. Parameters are also function scoped. | let: When a variable is declared using let, it uses what some call lexical-scoping or block-scoping. Unlike variables declared with var whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block. | const: They are like let declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as let, but you can’t re-assign to them. | . The syntax of declarations is as below: . var &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; let &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; const &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; . Example: . let num: number = 1; const PI: number = 3.14; let x: string = \"This is a string\"; const t: boolean = true; const f: boolean = false; let uninitialized: any; . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#variable-declaration-in-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#variable-declaration-in-typescript"
  },"71": {
    "doc": "Typescript Basics",
    "title": "Objects",
    "content": ". | Objects are similar to dictionaries with key-value pairs. | Arrays are iterable Objects with the keys as numbers. | . Examples: . const myObj: any = { key1: 'value1', key2: 'value2' }; console.log(myObj.key1); // prints 'value1' . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#objects",
    
    "relUrl": "/tutorials/week1-typescript-basics#objects"
  },"72": {
    "doc": "Typescript Basics",
    "title": "Control Flow Statements",
    "content": "Typescript contains the following control flow statements: . | If-Else | Switch | Ternary operator: Shorthand for if-else which returns a value. | . If condition syntax: . if(condition) { // executed when condition is true } if(condition) { // executed when condition is true } else { // executed when condition is false } if(condition) { // executed when condition is true } else if(condition2) { // checked only if condition is false // executed when condition2 is true } else { // executed when all conditions in the if-elseif ladder are false. } . Switch case syntax: . switch (variable) { case &lt;case1&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing case &lt;case2&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing default: // executed if variable does not match any prior cases } . Ternary Syntax: . let x = (condition) ? /* Executed when condition is true */ : /*Executed when condition is false*/; . Examples: . const str: string = \"ABCD\"; if(str === \"ABCD\") { console.log(\"it was true\"); } else { console.log(\"it was false\"); } switch (str) { case \"ABCD\": console.log('It was ABCD'); break; case \"WXYZ\": console.log('It was WXYZ'); break; default: console.log('It was something completely different') } let y: string = (str.includes(\"A\")) ? \"The string contains A\" : \"The string does not contain A\"; // y now contains \"The string contains A\" . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#control-flow-statements",
    
    "relUrl": "/tutorials/week1-typescript-basics#control-flow-statements"
  },"73": {
    "doc": "Typescript Basics",
    "title": "Equality vs Strict Equality",
    "content": "Typescript/JavaScript contain 2 equality operators: . | ==: Compares only the value of entities being compared. | ===: Compares the type and value of entities being compared. | . Example: . if(0 == '0') { } // Evaluates to true despite comparing string to number. if(0 === '0') { } // Evaluated to false because types are different. We recommend using strict equality (===) in all cases, and this recommendation is enforced by our linter. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#equality-vs-strict-equality",
    
    "relUrl": "/tutorials/week1-typescript-basics#equality-vs-strict-equality"
  },"74": {
    "doc": "Typescript Basics",
    "title": "Loops",
    "content": "Typescript contains the following loops: . | For | While | Do-while | . Examples: . for(let i: number = 0; i &lt; 10; i++) { } while(condition) { } do { } while(condition) . Tips: . | Entry-Level Loops: for and while loops are entry-level loops; they evaluate their condition before executing any statements. | Exit-Level Loop: The do...while loop is an exit-level loop; it will always execute the loop body at least once, regardless of the condition. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#loops",
    
    "relUrl": "/tutorials/week1-typescript-basics#loops"
  },"75": {
    "doc": "Typescript Basics",
    "title": "Array Functions",
    "content": "ForEach, Map, reduce, and filter are all array methods in JavaScript. Each one will iterate over an array and perform a transformation or computation. Each will return a new array based on the result of the function. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#array-functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#array-functions"
  },"76": {
    "doc": "Typescript Basics",
    "title": "ForEach",
    "content": "forEach() method calls a function for each element in the array. It returns the resultant array. Syntax . array.forEach(callback[, thisObject]); . Example . let num = [7, 8, 9]; num.forEach(function (value) { console.log(value); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#foreach",
    
    "relUrl": "/tutorials/week1-typescript-basics#foreach"
  },"77": {
    "doc": "Typescript Basics",
    "title": "Map",
    "content": "It is an array function that transforms the array according to the applied function and returns the updated array. It works on each element of an array. Syntax . array.map(callback[,object]) . callback - It is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type - List . Examples . //Calculate cube of each element with the help of map. function cube(n){ return n*n*n; } var arr=new Array(1,2,3,4) var newArr=arr.map(cube); console.log(newArr) // Output : [1,8,27,64] . In the above example, a function called “cube” is created and then is passed as a callback function into map(). ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#map",
    
    "relUrl": "/tutorials/week1-typescript-basics#map"
  },"78": {
    "doc": "Typescript Basics",
    "title": "Reduce",
    "content": "It also works on a callback for each element of an array. It reduces the result of this callback function from one array element to the other. Syntax . array.reduce(callback[,initalValue]) . callback - this parameter is the function to execute on each value in the array. intitalValue - this parameter is the object to use as the first argument of the first call of the callback. Examples . //To calculate product of every element of an array, var arr = new Array (1,2,3,4,5) var val = arr.reduce(function(a,b){ return a*b; }); //output =&gt; 120 . Calculate the total salary from a list of object, then you will use the reduce() like, . var employees = [ { id: 20, name: 'Ajay', salary:30000 }, { id: 24, name: 'Vijay', salary:35000 }, { id: 56, name: 'Rahul', salary:32000 }, { id: 88, name: 'Raman', salary:38000 } ]; var totalSalary= employees .reduce(function (total, record) { return total + record.salary; }, 0); //It will return the total salary of all the employees. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#reduce",
    
    "relUrl": "/tutorials/week1-typescript-basics#reduce"
  },"79": {
    "doc": "Typescript Basics",
    "title": "Filter",
    "content": "As the name suggests it can filter out the data/array elements on the basis of condition and return the result as a list. Basically, this function pushes the current element into a new array when the callback functions return true. Syntax . array.filter(callback[, object]) . callback - it is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type: List . Examples . //Calculate a list of even elements from an array : arr = new Array(1, 2, 3, 6, 5, 4) var newArr = arr.filter(function(record) { return record % 2 == 0; }); // output =&gt; [2,6,4] . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#filter",
    
    "relUrl": "/tutorials/week1-typescript-basics#filter"
  },"80": {
    "doc": "Typescript Basics",
    "title": "Functions",
    "content": ". | Functions usually “take in” data, process it, and “return” a result. Remember one function/method one job! . | There is a lot you can do with functions in JavaScript like assign them to variables, pass them to other functions, return them from functions, assign them to objects and prototypes, write properties to them, read those properties back, and so on, and TypeScript models all of those things with its rich type system, which we just learnt. | Typescript enables us to set the types for our function parameters and our return type. | Functions in Typescript are defined as below: . function functionName(argument1: &lt;type&gt;, defaultArgument: &lt;type&gt; = value, optionalArgument?: &lt;type&gt;): &lt;return type&gt; { // Function body } . | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#functions"
  },"81": {
    "doc": "Typescript Basics",
    "title": "Typing the function",
    "content": "A simple function in javascript would look like this: . // Named function function add(a, b) { return a + b; } . Now, let’s add types to our simple examples above: . function add(a: number, b: number): number { return a + b; } . You will usually explicitly annotate function parameters (a and b in this example)—TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters. The return type is inferred, but it’s a good practice to explicitly annotate it. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#typing-the-function",
    
    "relUrl": "/tutorials/week1-typescript-basics#typing-the-function"
  },"82": {
    "doc": "Typescript Basics",
    "title": "Invoking the function",
    "content": "When you invoke a function in TypeScript, you don’t need to provide any additional type information—just pass in some arguments, and TypeScript will go to work checking that your arguments are compatible with the types of your function’s parameters: . add(1, 2); // evaluates to 3 . Of course, if you forgot an argument, or passed an argument of the wrong type, TypeScript will be quick to point it out: . add(1); // Error TS2554: Expected 2 arguments, but got 1. add(1, 'a'); // Error TS2345: Argument of type '\"a\"' is not assignable // to parameter of type 'number'. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#invoking-the-function",
    
    "relUrl": "/tutorials/week1-typescript-basics#invoking-the-function"
  },"83": {
    "doc": "Typescript Basics",
    "title": "Optional and Default Parameters",
    "content": "Like in object and tuple types, you can use ? to mark parameters as optional. When declaring your function’s parameters, required parameters have to come first, followed by optional parameters: . function log(message: string, userId?: string) { let time = new Date().toLocaleTimeString() console.log(time, message, userId || 'Not signed in') } log('Page loaded') // Logs \"12:38:31 PM Page loaded Not signed in\" log('User signed in', 'da763be') // Logs \"12:38:31 PM User signed in da763be\" . You can provide default values for optional parameters. Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do). For example, we can rewrite log as: . function log(message: string, userId = 'Not signed in') { let time = new Date().toISOString() console.log(time, message, userId) } log('User clicked on a button', 'da763be') log('User signed out') . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#optional-and-default-parameters",
    
    "relUrl": "/tutorials/week1-typescript-basics#optional-and-default-parameters"
  },"84": {
    "doc": "Typescript Basics",
    "title": "Rest Parameters",
    "content": "If a function takes a list of arguments, you can of course simply pass the list in as an array: . function sum(numbers: number[]): number { return numbers.reduce((total, n) =&gt; total + n, 0); } sum([1, 2, 3]); // evaluates to 6 . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#rest-parameters",
    
    "relUrl": "/tutorials/week1-typescript-basics#rest-parameters"
  },"85": {
    "doc": "Typescript Basics",
    "title": "Functions as Constructors",
    "content": "In Typescript/Javascript, Functions can be used as constructors for creating objects. This is similar to classes, but not quite the same. For Examples: . | Constructors can’t have type parameters - these belong on the outer class declaration | Constructors can’t have return type annotations - the class instance type is always what’s returned | . function Person(this: any, firstName: string, lastName: string) { this.firstName = firstName; this.lastName = lastName; this.getFullName = function(): string { return this.firstName + ' ' + this.lastName; } } const person1 = new Person('first', 'last'); console.log(person1.getFullName()); // Returns 'first last'. class Point { x: number; y: number; // Normal signature with defaults constructor(x = 0, y = 0) { this.x = x; this.y = y; } } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#functions-as-constructors",
    
    "relUrl": "/tutorials/week1-typescript-basics#functions-as-constructors"
  },"86": {
    "doc": "Typescript Basics",
    "title": "Arrow Functions",
    "content": "Arrow Functions (also called fat arrow functions) are functions which have lexical ‘this’ and ‘arguments’. This are especially useful in class methods to preserve the context when using higher order functions. Examples: . let sum = (x: number, y: number): number =&gt; { return x + y; } sum(10, 20); //returns 30 . In the above example, sum is an arrow function. (x:number, y:number) denotes the parameter types, :number specifies the return type. The fat arrow =&gt; separates the function parameters and the function body. The right side of =&gt; can contain one or more code statements. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#arrow-functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#arrow-functions"
  },"87": {
    "doc": "Typescript Basics",
    "title": "Function Overloads",
    "content": "In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: . //function makeDate() with one parameter function makeDate(timestamp: number): Date; //function makeDate() with three parameters function makeDate(m: number, d: number, y: number): Date; //function makeDate() with one parameter and 2 default parameters function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); //No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#function-overloads",
    
    "relUrl": "/tutorials/week1-typescript-basics#function-overloads"
  },"88": {
    "doc": "Typescript Basics",
    "title": "Classes",
    "content": "Classes are blueprints for creating objects. | They can contain properties, methods, and a constructor. | All members of a class can have an access modifier: public, protected, private. | Members can also be static (shared across all instances of the class) and final (immutable). | Class properties may have getters and setters. | Classes can extend other classes. | Classes can implement interfaces. | . Creating a Class . A class definition can include the following: . | Fields − A field is any variable declared in a class. Fields represent data pertaining to objects | Constructors − Responsible for allocating memory for the objects of the class | Functions − Functions represent actions an object can take. They are also at times referred to as methods | . Examples: . class Person { private firstName: string = ''; protected middleName: string; public lastName: string = ''; private static final NeverGonnaGiveYouUp: any; protected static final NeverGonnaLetYouDown: any; public static final isRickRolled: boolean = true; constructor() { // I execute when you call new Person(). // No access modifier === public by default. // Make me private if implementing a singleton. } public anyoneCanCallMe(): void { this.childClassesCanCallMe(); } protected childClassesCanCallMe(): void { this.onlyPersonCanCallMe(); } private onlyAccessibleInsidePerson(): void { // I lied, anyone can call me if you know how. // Welcome to JavaScript :p } public get firstName(): string { return this.firstName; } public set firstName(firstName: string): void { this.firstName = firstName; } } const person = Person(); person.firstName = 'first'; console.log(person.firstName); person.anyoneCanCallMe(); class SpecialPerson extends Person { // I contain everything person has, and can extend/override it. constructor() { super() // I call the constructor for Person. } } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#classes",
    
    "relUrl": "/tutorials/week1-typescript-basics#classes"
  },"89": {
    "doc": "Typescript Basics",
    "title": "Creating an abstract class",
    "content": ". | Define an abstract class in Typescript using the abstract keyword. Abstract classes are mainly for inheritance where other classes may derive from them. We cannot create an instance of an abstract class. | An abstract class typically includes one or more abstract methods or property declarations. The class which extends the abstract class must define all the abstract methods. | . Example: . abstract class Person { abstract name: string; display(): void{ console.log(this.name); } } class Employee extends Person { name: string; empCode: number; constructor(name: string, code: number) { super(); // must call super() this.empCode = code; this.name = name; } } let emp: Person = new Employee(\"James\", 100); emp.display(); //James . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#creating-an-abstract-class",
    
    "relUrl": "/tutorials/week1-typescript-basics#creating-an-abstract-class"
  },"90": {
    "doc": "Typescript Basics",
    "title": "Type Aliases",
    "content": "We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name. A type alias is exactly that - a name for any type. The syntax for a type alias is: . type Point = { x: number; y: number; }; function printCoord(pt: Point) { console.log(\"The coordinate's x value is \" + pt.x); console.log(\"The coordinate's y value is \" + pt.y); } printCoord({ x: 100, y: 100 }); . You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type: . type ID = number | string; . Note that aliases are only aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type: . type UserInputSanitizedString = string; function sanitizeInput(str: string): UserInputSanitizedString { return sanitize(str); } // Create a sanitized input let userInput = sanitizeInput(getInput()); // Can still be re-assigned with a string though userInput = \"new input\"; . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#type-aliases",
    
    "relUrl": "/tutorials/week1-typescript-basics#type-aliases"
  },"91": {
    "doc": "Typescript Basics",
    "title": "Interfaces",
    "content": "Interfaces are used to define contracts for interaction with external entities. If an interface has a property/method, an Object/Class which implements it must have it. Interfaces can be used to define custom types for Objects in Typescript. Examples: . //Interface IPerson respresents a person by attributes firstName and lastName and a method to getFullName() interface IPerson { firstName: string; lastName: string; getFullName(): string; } //Class Person implements interface Iperson. Person class must contains all the attributes and methods of interface. class Person implements IPerson { public firstName: string = ''; public lastName: string = ''; public getFullName(): string { return this.firstName + ' ' + this.lastName; } // It can contain any other properties/methods but must contain those in the interface. } const person: IPerson = new Person(); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#interfaces",
    
    "relUrl": "/tutorials/week1-typescript-basics#interfaces"
  },"92": {
    "doc": "Typescript Basics",
    "title": "Custom types",
    "content": ". | For complicated types (usually required for Objects), it is recommended to use an interface. | Additionally, typescript contain the ‘type’ keyword which can be used to create new types. | This is generally used when a union of different types is required. | . Examples: . interface IStudent { name: string; age: number; studentID: number; gender: string; isEnrolled: boolean; } const student: IStudent = { name: 'name', age: 20, studentID: 111111111, gender: 'hidden' isEnrolled: true; }; type StringOrNumber = string | number; let x = 1; x = 'some string'; . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#custom-types",
    
    "relUrl": "/tutorials/week1-typescript-basics#custom-types"
  },"93": {
    "doc": "Typescript Basics",
    "title": "Generics",
    "content": ". | Generics allow us to pass different types to a function/class making it more generalized. | This will be especially useful when working with http requests. | . Examples: . function myFunc&lt;T&gt;(data: T): T { console.log(data); return data } let x: string = myFunc&lt;string&gt;('some string'); let y: number = myFunc&lt;number&gt;(5); class myClass&lt;T&gt; { } interface IMyInterface&lt;T&gt; { } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#generics",
    
    "relUrl": "/tutorials/week1-typescript-basics#generics"
  },"94": {
    "doc": "Typescript Basics",
    "title": "Modules",
    "content": "A Module in typescript is defined by using the ‘Import’ or ‘Export’ keywords within a file. Variables declared in a module are scoped locally and are not added to the global scope. | Export makes the variables and functions from a file visible outside it. | Import allows use to use variables and functions exported by another file. | . Examples: . // file1.ts export const someVar: string = 'Variables can be exported too.'; export default function add(x: number, y: number): number { return x + y; } export function subtract(x: number, y: number): number { return x - y; } function multiply(): void { throw new Error(); } // file2.ts import add from './file1'; // curly braces are not required if export default is used. // There can be only 1 export default in a while. Use it if file has only 1 export. import { subtract } from './file1'; add(1, 2); subtract(2, 1); // multiply cannot be imported. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#modules",
    
    "relUrl": "/tutorials/week1-typescript-basics#modules"
  },"95": {
    "doc": "Typescript Basics",
    "title": "Object oriented programming concepts using typescript",
    "content": "Object Oriented Programming or OOP is a programming paradigm that has four principles which are: . | Inheritance | Polymorphism | Abstraction | Encapsulation | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#object-oriented-programming-concepts-using-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#object-oriented-programming-concepts-using-typescript"
  },"96": {
    "doc": "Typescript Basics",
    "title": "Inheritance",
    "content": "TypeScript supports the concept of Inheritance. Inheritance is the ability of a program to create new classes from an existing class. The class that is extended to create newer classes is called the parent class/super class. The newly created classes are called the child/sub classes. A class inherits from another class using the ‘extends’ keyword. Child classes inherit all properties and methods except private members and constructors from the parent class. However, TypeScript doesn’t support multiple inheritance. Syntax: . class child_class_name extends parent_class_name . Example: . //Parent class Shape class Shape { Area:number constructor(a:number) { this.Area = a } } //Child class Circle that inherits properties of Shape class Circle extends Shape { disp():void { console.log(\"Area of the circle: \"+this.Area) } } var obj = new Circle(223); obj.disp() . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#inheritance",
    
    "relUrl": "/tutorials/week1-typescript-basics#inheritance"
  },"97": {
    "doc": "Typescript Basics",
    "title": "Polymorphism",
    "content": "When multiple classes inherit from a parent and override the same functionality, the result is polymorphism. Each of those child classes now implements a property or method, but they each may have their own way of performing that implementation. Alternatively, one child class might override the parent’s members while another child doesn’t but just accepts the parent class’s implementation instead. This also demonstrates polymorphic behavior, since those behaviors are different between the siblings. class CheckingAccount { open(initialAmount: number) { // code to open account and save in database } } class BusinessCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt; 1000) { throw new Error(\"Business accounts must have an initial deposit of 1.000 Euros\") } super.open(initialAmount); } } class PersonalCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt;= 0) { throw new Error(\"Personal accounts must have an initial deposit of more than zero Euros\") } super.open(initialAmount); } } . In the above code sample shows, the two child classes have different business rules to implement when it comes to opening an account – mainly different opening balances. Because both children have a method to open the account but both children choose to do it differently means the behavior is polymorphic. To achieve polymorphism, inherit from a base class, then override methods and write implementation code in them. In addition to overriding methods, you can overload methods to achieve polymorphism. Overloaded methods are methods that have different signatures (i.e., different data types or number of arguments) with the same name. However, in TypeScript, methods aren’t overloaded by simply modifying the types or number of arguments like in some other languages. To create an overload in TypeScript, you can either add optional arguments to a method, or overload function declarations in an interface and implement the interface. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#polymorphism",
    
    "relUrl": "/tutorials/week1-typescript-basics#polymorphism"
  },"98": {
    "doc": "Typescript Basics",
    "title": "Abstraction",
    "content": "Abstraction is a way to model objects in a system that creates a separation of duties between class or type and the code that inherits it. A developer creates a type, i.e., a class or interface, and that type specifies what the calling code should implement, but not how. So it’s the job of the abstract type to define what needs to be done, but up to the consuming types to actually do those things. To enforce abstraction, inherit or implement from abstract classes and interfaces. For example, some bank accounts have fees. You can create a Fee interface that defines a method for charging a fee. Fees don’t apply to all types of accounts, so it’s best to create an interface that can be applied to specific classes anywhere in the inheritance hierarchy. A checking account might charge fees, where its parent and sibling, the generic bank account and savings accounts might not. interface Fee { chargeFee(amount: number ); } // parent BankAccount and sibling SavingsAccount do not implement Fee interface class BankAccount { ... } class SavingsAccount extends BankAccount { ... } // checking implements Fee class CheckingAccount extends BankAccount implements Fee { chargeFee(amount: number) {} } . Children classes inherit interface members that have been implemented in their parent, so if a BusinessChecking account has inherited from the CheckingAccount class, then it inherits that implementation. // BusinessChecking inherits CheckingAccount and therefore Fee class BusinessChecking extends CheckingAccount { … } // Code that uses BusinessChecking can call chargeFee function CalculateMonthlyStatements() { let businessChecking = new BusinessChecking(); businessChecking.chargeFee(100); } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#abstraction",
    
    "relUrl": "/tutorials/week1-typescript-basics#abstraction"
  },"99": {
    "doc": "Typescript Basics",
    "title": "Encapsulation",
    "content": "Encapsulation is a key part of Object Oriented Programming that is a way to structure code so that a certain block of code has specific access points for external code. The term for this is “visibility” or “accessibility”. Visibility defines what code from one method, property, or class can call code in another method, property, or class. In TypeScript, we enforce encapsulation with methods and properties that only allow access to data that we control. The Withdraw method below does that by doing the calculation and updating the class level _balance field. The Balance property then returns the private _balance field to the calling code. Withdraw(amount: number): boolean { if (this._balance &gt; amount) { this._balance -= amount return true; } return false; } private _balance: number; get Balance(): number { return this._balance; } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#encapsulation",
    
    "relUrl": "/tutorials/week1-typescript-basics#encapsulation"
  },"100": {
    "doc": "Typescript Basics",
    "title": "General Guidelines",
    "content": ". | Naming conventions . | use kebab-case for file names. | Use camelCase for variable and function names. | Use PascalCase for Class and constructor function names. | . | Prefer descriptive names over random letters. | Although typing is optional in typescript, it is not optional for this course. | Always use strict equality. | Use a linter. (as specified on course website) | Use a prettifier. (If the linter doesn’t do it already) | Use general coding guidelines as discussed in Week1. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#general-guidelines",
    
    "relUrl": "/tutorials/week1-typescript-basics#general-guidelines"
  },"101": {
    "doc": "Typescript Basics",
    "title": "tsconfig",
    "content": "What is the tsconfig.json file? . | The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. | JavaScript projects can use a jsconfig.json file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default. | Note: In many packages, a configuration file is included, featuring predefined settings that typically require no alterations. Also, you may not need this for simple projects like hello world. A project is compiled in one of the following ways: | . Using tsconfig.json or jsconfig.json: . | By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain. | By invoking tsc with no input files and a –project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file, or a path to a valid .json file containing the configurations. When input files are specified on the command line, tsconfig.json files are ignored. | . Example tsconfig.json files: Using the files property . \"compilerOptions\": { \"module\": \"commonjs\", \"noImplicitAny\": true, \"removeComments\": true, \"preserveConstEnums\": true, \"sourceMap\": true }, \"files\": [ \"core.ts\", \"sys.ts\", \"types.ts\", \"scanner.ts\", \"parser.ts\", \"utilities.ts\", \"binder.ts\", \"checker.ts\", \"emitter.ts\", \"program.ts\", \"commandLineParser.ts\", \"tsc.ts\", \"diagnosticInformationMap.generated.ts\" ] } . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-typescript-basics#tsconfig",
    
    "relUrl": "/tutorials/week1-typescript-basics#tsconfig"
  },"102": {
    "doc": "Unit Testing with Jest",
    "title": "Understanding Unit Testing",
    "content": "At some point, every programmer has wondered why they should spend time writing test cases instead of focusing on implementing a new feature. The reason for this is that it is important! In this tutorial, we’ll go through several aspects of unit testing, with a focus on utilizing Jest. Before we get into that, let’s define unit testing and why it’s so important in the real world. Unit testing is not a new concept; it has been around for a long time. “Unit tests are often automated tests prepared and executed by software engineers to check that a portion of an application (referred to as a “unit”) matches its design and behaves as expected,” according to Wikipedia. So, to put it another way, it’s a technique to undertake rigorous testing of every single function/module in isolation. Unit testing technques: . | Black Box Testing : It is a process of validating a function’s input and output without any knowledge of it’s internal implementation details. | White Box Testing : Unlike Black Box testing, white box testing focuses on testing the specific internal code flows, uncovering any unidentified error or bug in that component. | Gray Box Testing : Gray Box testing is a combination of the two above wherein partial knowledge of the internal code is needed. This strategy lowers a tester’s reliance on a developer for every minor issue, allowing the tester to detect and resolved it alone. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#understanding-unit-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#understanding-unit-testing"
  },"103": {
    "doc": "Unit Testing with Jest",
    "title": "Testing with Jest",
    "content": " ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#testing-with-jest",
    
    "relUrl": "/tutorials/week1-unit-testing#testing-with-jest"
  },"104": {
    "doc": "Unit Testing with Jest",
    "title": "Basics",
    "content": "To understand the basics of unit testing, let us look at the file called ‘calculator.ts’ present in the directory src/services/math/. This file contains a class called Calculator with a method for add() defined as shown below: . // Contents of src/services/math/calculator.ts export default class Calculator { public add(num1: number, num2: number): number { const result: number = num1 + num2; console.log(\"The result is: \", result); return result; } } . Let us write some tests for this code using jest. The test code will go into a file in the same directory titled ‘calculator.spec.ts’. Create this file now. This pattern of ‘file-name.spec.ts’ is how you should name all of your test files when using jest. All test files start with a suite. A suite is a collection of tests (or a logical grouping of tests). In jest, a suite is created by using the function describe(). The suite takes 2 arguments: the 1st being the description of the suite and the second being a callback function. Additionally, suites can be nested to form logical groups. Suites can further be broken down into 3 components that we will explore in detail shortly: . | Setup | Teardown | Test | . Syntax: . describe(\"Description of suite\", () =&gt; { // The tests go here. }); . Suites can be used to make debugging easier when you are using a large number of tests. Here is one recommended suite hierarchy: . | Top level describe should contain the file path after src. | Second describe should contain the name of the Class/File being tested. | Subsequent describe blocks should contain the name of the function being tested. | . Using this hierarchy, the test file for the above example would look as follows: . describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { // Tests for add() go here. }); }); }); . Specs . A spec is an actual test that executes some code and asserts some result. A test is created using the keyword it() or test(). Similar to describe(), it() takes 2 arguments, the first being the description of the test and the second being a callback. Generally, we want to describe what the code should do in the description of it() and assert the described behavior within the test. Each test can be broken down into 3 parts (Assemble, Act, Assert) which makes up the AAA pattern. Optionally, there may be a clean-up/teardown step after the assert. Syntax: . it(\"should check a specific behaviour\", () =&gt; {}); . Let us write a simple test for our add() method to check 1 + 1 = 2. We start by adding a spec to the suite we created previously. describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { // Assemble // Act // Assert }); }); }); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#basics",
    
    "relUrl": "/tutorials/week1-unit-testing#basics"
  },"105": {
    "doc": "Unit Testing with Jest",
    "title": "Matchers",
    "content": ".toEqual() vs .toBe() vs .toStrictEqual() . All three matchers are used to test equality, though they have slight but important differences. To understand these differences, let us take a look at the example of Store.ts with the below code. export default class Store { private static _data: any = null; public static getData(): any { return Store._data; } public static setData(data: any): void { Store._data = data; } } . | Use .toEqual() to compare recursively all properties of object instances (also known as “deep” equality). It calls Object.is to compare primitive values, which is even better for testing than ‘===’, the strict equality operator. This is the most commonly used matcher. | . describe(\"utils &gt; store\", () =&gt; { describe(\"Store\", () =&gt; { beforeEach(() =&gt; { Store[\"_data\"] = undefined; }); describe(\"setData()\", () =&gt; { it(\"should assign the input data to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store.setData(mockData); expect(Store[\"_data\"]).toEqual(mockData); }); }); describe(\"getData()\", () =&gt; { it(\"should return an object equal to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); }); }); }); }); . | Use .toBe() to compare primitive values or to check referential identity of object instances. It calls Object.is to compare values, which is even better for testing than ‘===’, the strict equality operator. | . describe(\"getData()\", () =&gt; { it(\"should return an object with a reference different to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); expect(returnedValue).not.toBe(mockData); expect(Store[\"_data\"]).toBe(mockData); }); }); . | Use .toStrictEqual() to test that objects have the same types as well as structure. This checks for undefined in Objects and sparseness in Arrays. | { key: undefined } is not strictly equal to { }. | [ , 1] is not strictly equal to [undefined, 1]. | . | . it(\"should return an object strictly equal to object stored in Store._data\", () =&gt; { const mockData = { key: \"value\" }; const mockDataWithUndefined = { key: \"value\", key2: undefined }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toStrictEqual(mockData); expect(returnedValue).toEqual(mockDataWithUndefined); expect(returnedValue).not.toStrictEqual(mockDataWithUndefined); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#matchers",
    
    "relUrl": "/tutorials/week1-unit-testing#matchers"
  },"106": {
    "doc": "Unit Testing with Jest",
    "title": "AAA",
    "content": "Assemble . In order to run a test, we need to first assemble it. This may include creating instances of classes/variables, setting up test data for inputs, setting up spies/stubs/mocks (which will be covered in subsequest sections), or setting up the expected output. In simple cases, one may not need to assemble the test. This phase is very similar to the setup phase. In our example, let us create an instance of the Calculator class as part of assembling the test. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); // Act // Assert }); }); }); }); . Act . In this step, we actually execute the function under test with required inputs and get the returned result (if any). In our example, we will invoke the add() method with inputs (1, 1) and get the result. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); // Assert }); }); }); }); . Assert . Assertion is a statement that validates the behavior of our code by comparing the actual result against the expected results. There are many assertions provided by Jest, including some useful assertions we will use throughout our tests. Some of these assertions are listed below: . | expect(actual).toEqual(expected) // Expects both entities to have the same value. | expect(actual).toBe(expected) // Expects both entities to be the same. | expect(spy/stub/mock).toHaveBeenCalled() // Expects a function being spied/stubbed/mocked to be invoked. | expect(spy/stub/mock).toHaveBeenCalledWith([arguments]) // Expects a function being spied/stubbed/mocked to be invoked with specified arguments. | expect(actual).toBeDefined() // Expects the entity to be defined. | expect(actual).not. // Negates the assertion. Can be chained with any matchers above | await expect(error causing code returning a promise).rejects.toThrowError() // Waits for the error throwing code that returns promise (e.g. an API call) to throw the error and asserts the error was thrown. | . A full list of matchers can be found here. In our example, we can use the .toEqual() matcher. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#aaa",
    
    "relUrl": "/tutorials/week1-unit-testing#aaa"
  },"107": {
    "doc": "Unit Testing with Jest",
    "title": "Setup and Teardown",
    "content": "Often in tests, we need some things to happen before a test actually runs and some things to happen after it. This may include resetting/initializing values, setting up test data, setting up spies/stubs/mocks, cleaning up variables after a test, or resetting spies/stubs/mocks. Sometimes these steps may need to be repeated for each test. This is where the setup and teardown can be especially useful. Jest Provides 2 methods for setup and 2 methods for teardown: . | beforeAll(): Runs one time before all the tests in a suite. | beforeEach(): Runs before every test in a suite. | afterEach(): Runs after every test in a suite. | afterAll(): Runs once after all tests in a suite. | . In our example, notice we created an instance of calculator in our Assemble phase. We will probably have multiple tests for the calculator that will require this instance. In order to avoid repeating this in every step, let us move this to the setup phase and add a teardown to clear this after all tests. Note: Use beforeEach()/afterEach() if the function/class stores state, and we need a clean instance for each test. In our case, calculator does not store any state, and we can share the same instance across tests with out any side effects. Hence, we will use beforeAll()/afterAll(). import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . Let us add another test to cover a different scenario, such as adding negative numbers. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); it(\"should return -2 when inputs are -1 and -1\", () =&gt; { const result: number = calculator.add(-1, -1); expect(result).toEqual(-2); }); }); }); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#setup-and-teardown",
    
    "relUrl": "/tutorials/week1-unit-testing#setup-and-teardown"
  },"108": {
    "doc": "Unit Testing with Jest",
    "title": "Mock Testing",
    "content": "As a project grows so do the interdependencies in the project. A function under test can have dependencies from various external entities. This may include other functions, network requests, database connections, or built-in connections. Spies, Stubs, and Mocks are ways of dealing with such external dependencies. You can read more on what you can do with spies/stubs/mocks here. Spy . A spy is a watcher on a function that tracks various properties of the function being spied on. This can return information such as whether a function was invoked, how many times it was invoked, and what argument it was invoked with. A spy on a function is created using the syntax const spy = jest.spyOn(object, 'methodName'); . Note: The function being spied on actually executes. In our example, we have an external dependency on console.log(). Let us add a spy and test for it. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(console, \"log\"); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); }); }); }); . Mock . A mock is function which replaces an existing function. In our example, if we wanted to change the behavior of console.log() for our tests, we can do so using a mock. A mock implementation can be substituted for a spy or a jest.fn(). The syntax is as below: . spy.mockImplementation(() =&gt; { // new function body goes here. }); . Note: The function being mocked does not execute. In our example, if we wanted to replace the behavior of console.log(), we can do so as shown: . it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(console, \"log\"); logSpy.mockImplementation(() =&gt; { // This will no longer print to console. }); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . Warning: Watch out for circular dependencies in mock implementations. Stub . A stub is a special kind of mock which does not require an alternate implementation but instead returns some value that we specify. When a stub gets invoked, it does not invoke the actual function, but returns the desired value instead. The syntax is as below: . spy.mockReturnValue(someValue); . To return a promise, we can use: . spy.mockResolvedValue(someValue); . This can be especially handy when stubbing Axios requests. Using a stub in our example simply prevents console.log() from being executed, since it does not return a value anyway. it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(console, \"log\"); logSpy.mockReturnValue(); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#mock-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#mock-testing"
  },"109": {
    "doc": "Unit Testing with Jest",
    "title": "Testing Asynchronous Code",
    "content": "Promise . In previous tutorials, we have used Axios to make http requests which return promises. This is how we can write tests for axios requests. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } } . We can test the above code as follows: . // Assuming we have done the setup as in previous tests describe(\"getData()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getData(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should return the status as 200\", async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); const response = await httpService.getData(); expect(response.status).toEqual(200); getStub.mockRestore(); }); }); . Note: You can return different values for subsequent calls to a stub. Occasionally, you may run into situations where an http request is made but no promise is returned. This is often found in cases involving “fire and forget” calls or a central store with an Observable pattern implementation (e.g. Redux with react). We cannot await a function that does not return a promise. However, we can use fake timers to simulate passage of time to test such asynchronous behavior. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } public getDataAndSetStore(): void { axios.get(\"/myUrl\").then((res) =&gt; { Store.setData(res.data); }); } } . We can test the above functionality as follows: . describe(\"getDataAndSetStore()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getDataAndSetStore(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should set the data in store\", async () =&gt; { const addDataStub = jest.spyOn(Store, \"setData\").mockImplementation(); const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: \"myData\" }); jest.useFakeTimers(); httpService.getDataAndSetStore(); jest.runAllTimers(); await Promise.resolve(); expect(addDataStub).toHaveBeenCalledWith(\"myData\"); addDataStub.mockRestore(); getStub.mockRestore(); jest.useRealTimers(); }); }); . You can read more about jest timers here. Callbacks . Callbacks are one of the most commonly used patterns for asynchronous programming in JavaScript/TypeScript. Consider the below callback function use case: . test('Check if I am a true husky', () =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); } fetchData(callback); }); . Here, fetchData() is a function that takes a callback and would call that callback function later in it’s implementation. Now consider 2 scenarios: . case 1: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am from Northeastern!'); }, 1000); } . case 2: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am not from Northeastern!'); }, 1000); } . The test case would still pass in either of the above scenarios since fetchData() is an async function, which means the program will not wait for the call to complete. The correct way to test a callback would be using the argument done in the test like shown in below example: . test('Check if I am a true husky', (done) =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); done(); } fetchData(callback); }); . Now, the program would wait for done to be invoked. This implementation would correctly test both the above scenarios. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#testing-asynchronous-code",
    
    "relUrl": "/tutorials/week1-unit-testing#testing-asynchronous-code"
  },"110": {
    "doc": "Unit Testing with Jest",
    "title": "UI Testing",
    "content": "Testing UIs can be very tricky, especially when we want to test features involving user interaction (e.g. a user clicking on a button). However, there are some useful tools that can help us. The React Testing Library provides many helpful features that can help us. import {render, screen} from '@testing-library/react' import Counter from './Counter' it('renders the Counter component correctly', async () =&gt; { render(&lt;Counter /&gt;); // Will throw error if not found screen.getByText(\"Count: 0\" ) screen.getByText(\"Click me!\" ) }) . Above is a very simple test to ensure that our Counter component renders as expected with out any user input. Suppose now that we wanted to test user interaction with the page: . import {render, fireEvent, screen} from '@testing-library/react' import Counter from './Counter' it('correctly renders the updated count after the user clicks the button', async () =&gt; { render(&lt;Counter /&gt;); screen.getByText(\"Count: 0\" ) fireEvent.click(screen.getByRole('button')) screen.getByText(\"Count: 1\" ) }) . A full list of testing functions from React Testing Library can be found here. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#ui-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#ui-testing"
  },"111": {
    "doc": "Unit Testing with Jest",
    "title": "Setting up testing using Jest in VSCode",
    "content": "Testing can sometimes get cumbersome as the user is expected to remember all the options provided by Jest to run a specific set of tests, or otherwise the user will have to run the entire test suite just to verify the result of a single test case. Not anymore! . With vscode-jest, you have complete control over the way you want to run tests, with many features that visually inform the users about which specific line is failing with what error. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#setting-up-testing-using-jest-in-vscode",
    
    "relUrl": "/tutorials/week1-unit-testing#setting-up-testing-using-jest-in-vscode"
  },"112": {
    "doc": "Unit Testing with Jest",
    "title": "Features",
    "content": ". | Starts Jest automatically when you’re in a root folder project with Jest installed. | Show individual fail / passes inline. | Show fails inside the problem inspector. | Highlights the errors next to the expect functions. | Adds syntax highlighting to snapshot files. | A one button update for failed snapshots. | Show coverage information in files being tested. | Help debug jest tests in vscode. | Supports multiple test run modes (automated, manual, and hybrid onSave) to meet user’s preferred development experience. | Track and shows overall workspace/project test stats. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#features",
    
    "relUrl": "/tutorials/week1-unit-testing#features"
  },"113": {
    "doc": "Unit Testing with Jest",
    "title": "Installation",
    "content": "Direct Installation . | Open Visual Studio Code, go to the extension tab. | Search for “Jest” with the publisher name as “Orta”. | Click “Install”. | . From Visual Studio Marketplace . | Visit Jest - Visual Studio Marketplace and click “Install”. | Allow the browser to open VSCode as shown (might be different for macOS/Linux systems) by clicking on Continue. | Once VSCode is open, click on “Install”. | . Once installed, the extension should work out of the box without any extra configuration for most of the homework handouts and project starter code. You can verify the installation by checking if the following is visible to you when you open a project which has Jest configured (VSCode restart maybe required.). If restarting Jest does not work, you can run the following in your VSCode by opening VSCode’s command palette (Ctrl + Shift + P in Windows, Cmd + Shift + P in macOS) and run the following - “Jest: Start All Runners”. Additional Extensions and Libraries . If you would like to run each test individually (and all tests in test suites collectively), VSC extenstion called “Jest Runner” will be very useful. You can also explore jest extended library that offers additional matchers for testing. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#installation",
    
    "relUrl": "/tutorials/week1-unit-testing#installation"
  },"114": {
    "doc": "Unit Testing with Jest",
    "title": "Configuration",
    "content": "As of the latest stable version, the extension is set to run all tests whenever any change is made to the files containing the tests. You can modify the behaviour to manual execution where you can run specific test cases as and when required. This can be modified by changing the \"jest.autoRun\" setting as follows - . | \"jest.autoRun\": {\"watch\": true} =&gt; will start the jest with the watch flag and leave all tests at “unknown” state until changes are detected. | \"jest.autoRun\": {\"watch\": true, \"onStartup\": [\"all-tests\"]} =&gt; will start running all tests upon project launch to update overall project test stats, followed by the jest watch for changes. | \"jest.autoRun\": \"off\" =&gt; there will be no automatic test run, users will trigger test run by either command or context-menu. | \"jest.autoRun\": {\"watch\": false, \"onSave\": \"test-file\"} =&gt; the extension will trigger test run for the given test file upon save. | \"jest.autoRun\": {\"watch\": false, \"onSave\": \"test-src-file\"} =&gt; the extension will trigger test run for the given test or source file upon save. | . An example of changing the extension to run in manual mode is demonstrated below - . NOTE - You will only be able to Run specific test cases as and when required only when autoRun is off. However, you’ll be able to Debug any test cases in all available modes. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#configuration",
    
    "relUrl": "/tutorials/week1-unit-testing#configuration"
  },"115": {
    "doc": "Unit Testing with Jest",
    "title": "Debugging Tests",
    "content": "Once the extension is setup and confirmed to be working, we can now begin debugging the tests. You can do so by opening the testing tab from the left sidebar in VSCode to view all the tests present in the current project. You can also navigate to the specific test file manually, and you will notice some icons/action buttons in the editor next to each test. Right clicking on the icons will bring up a test-specific context menu which will have options to debug the specific test. Be sure to place breakpoints in the specific pieces of code by clicking to the left of the line numbers. If everything is setup correctly, the debugger in VSCode will pause at the breakpoint you set and you can check the values of the variables by hovering over the said variable. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#debugging-tests",
    
    "relUrl": "/tutorials/week1-unit-testing#debugging-tests"
  },"116": {
    "doc": "Unit Testing with Jest",
    "title": "General Guidelines For Writing Tests",
    "content": "Note: The following will be used as a reference when grading assignments. | Tests should be hermetic. | Reduce flakiness. | Flaky tests are those that fail intermittently: . | Nondeterminism (e.g., hash codes, random numbers); | Timing issues (e.g., threads, network). | Availability of Resources | . | . | Tests should be clear. | After failure, should be clear what went wrong. | . | Tests should be scoped as small as possible. | Faster and more reliable. | . | Tests should make calls against public APIs. | Or they become brittle | Brittle tests are those that are not self-contained: . | Ordering of tests (e.g., assume prior state) | . | . | . Note: The following will not be used as a reference when grading assignments. But you should try following these guidelines as much as you can. | Write tests based on the expected behavior, not based on the interpretation/implementation of it. | Test assertion (expect) should match the test description. | Each spec should test only 1 thing (preferably with 1 assertion per test). | Organize tests using suites (i.e. each method has it’s own suite). | Use setup and teardown functions to reduce code duplicity. | Code duplicity in tests is preferred over complicated logic to reduce it. | If your tests need tests, they have no value. | . | Cover the happy path for your code first. | Follow up with edge cases. | End with error scenarios. | . | Mock/Stub all external dependencies. | Clear the mocks after each test. | . | If large test data is being used, ensure clean-up after tests to prevent memory leaks. | Code coverage is a deceptive measure. 100% coverage does not mean 100% tested code. | A well designed test suite improves the quality and reliability of code. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing#general-guidelines-for-writing-tests",
    
    "relUrl": "/tutorials/week1-unit-testing#general-guidelines-for-writing-tests"
  },"117": {
    "doc": "Unit Testing with Jest",
    "title": "Unit Testing with Jest",
    "content": "This tutorial covers the basics on unit testing with Jest. By the end of this tutorial, you will have an introduction to unit testing with jest, best practices, and some handy tricks and tips to use in your tests. Starter code is available here, and finished code with tests covered in this tutorial can be found here. We strongly recommend using the completed solution only for reference and implementing the tutorial step by step from the starter code. Note: Run npm i on the handouts before proceeding to update/run the tests. Contents: . | Understanding Unit Testing | Testing with Jest . | Basics . | Specs | . | Matchers . | .toEqual() vs .toBe() vs .toStrictEqual() | . | AAA . | Assemble | Act | Assert | . | Setup and Teardown | Mock Testing . | Spy | Mock | Stub | . | Testing Asynchronous Code . | Promise | Callbacks | . | UI Testing | . | Setting up testing using Jest in VSCode . | Features | Installation . | Direct Installation | From Visual Studio Marketplace | Additional Extensions and Libraries | . | Configuration | Debugging Tests | . | General Guidelines For Writing Tests | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-unit-testing",
    
    "relUrl": "/tutorials/week1-unit-testing"
  },"118": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Conditions of Satisfaction",
    "content": "A user story is an informal, general explanation of a software feature written from the perspective of the end user or customer. A user story is always of the following form: . As a &lt;role&gt; I can &lt;perform action&gt; so that I can &lt;receive benefit&gt; . User stories represent something the user/customer might want. There will be many ways to give the user/customer the benefit that they want. We need to refine these in order to determine what to build. We call these refinements “conditions of satisfaction” (COS) . A COS should be a specific capability or behavior that the user expects, in the user’s terms. It should be visible to and verifiable by the user. The COS is a guide to the implementation team. It should be specific enough so that the implementation team has a clear idea of what they are building. There still may be many ways to implement a COS. For example, a COS probably would not specify any of the graphic or layout details; these would likely be left to the implementation team. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#user-stories-and-conditions-of-satisfaction",
    
    "relUrl": "/tutorials/week1-user-stories#user-stories-and-conditions-of-satisfaction"
  },"119": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Project Planning",
    "content": "In planning a project, need to assign priorities to each user story and Condition of Satisfaction. Priorities tell us the order in which COS and their associated engineering tasks should be addressed, and how much effort should be devoted to each of them. There are many ways to describe priorities. For example, a user story might be described as Essential, Desirable, or Extension: . | Essential means the project is useless without it. | Desirable means the project is less usable without it, but is still usable. | Extension describes a User story or COS that is desirable, but may not be achievable within the scope of the project. | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#user-stories-and-project-planning",
    
    "relUrl": "/tutorials/week1-user-stories#user-stories-and-project-planning"
  },"120": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "Minimum Viable Product (MVP)",
    "content": "An MVP is a product that consists of all essential user stories. Developers should prioritize those above others. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#minimum-viable-product-mvp",
    
    "relUrl": "/tutorials/week1-user-stories#minimum-viable-product-mvp"
  },"121": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Test-Driven Development",
    "content": "We model the development process as a cycle of refinements: . | User Stories | Conditions of Satisfaction | Testable behaviors | Executable Tests | Engineering Tasks (Code) | . As we proceed down these refinements, we will likely go back and revisit design decisions that we made at earlier stages. This is the topic of Module 02. ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#user-stories-and-test-driven-development",
    
    "relUrl": "/tutorials/week1-user-stories#user-stories-and-test-driven-development"
  },"122": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "Examples",
    "content": " ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#examples",
    
    "relUrl": "/tutorials/week1-user-stories#examples"
  },"123": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories:",
    "content": "User Story #1: . As a manager, I want to track my subordinates’ progress, so that the organization’s business goals are met. [Probably too general; in the agile terminology, this might be an “epic”, which is then refined into a set of user stories] . User Story #2: . As a player in covey.town, I want to be able to play a game of connect4 with another player, so that I can pass the time enjoyably. (Essential) . User Story #3: . As a player in covey.town, I want to see how well I’m doing at connect4 compared to other players, so I can feel superior to them. (Desirable) . User Story #4: . As a player in covey.town, I want to learn different strategies for connect4, so I can win more games. (Extension) . User Story #5: . As a user of Covey.Town, I want to be able to interact with other users in different activities like private chat, playing games, etc. while providing ability to customize user avatars to make the town more fun. (Essential but too general. Best to split it in 3 different stories one for private chat, one for games and one for customization.) . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#user-stories",
    
    "relUrl": "/tutorials/week1-user-stories#user-stories"
  },"124": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "Conditions of Satisfaction:",
    "content": "For User Story #2: . | There should be a Connect4 area in the town, where players can play Connect4. (Essential) | Whenever there are two players in the same Connect4 area, a Connect4 game is started between them. (Essential) | The status of the Connect4 game is presented in graphical form on the screen (Essential). | When one player wins (or there is a draw), both players are notified of the result. (Essential) | When a player makes a move in the Connect4 game, the tile visibly drops onto the game board, and a suitable sound effect is emitted (Extension) | If other players enter a Connect4 area while a game is going on, they can see the status of the game also (Desirable) | . [Note: these COSs do not describe the game board in detail, though that is pretty standard. They also do not describe what happens to the two players when the game is over. Do they stay in the area and spectate? Do the next two players play? Does the first spectator play the winner of the game? etc. etc.] . | There should be a way for one player to challenge another to play the game of Connect4, no matter where they are in the town. (This might be an Extension, or it might be a different user story). | . For User Story #3: . | There should be a leaderboard showing the Connect4 ranking of all the players in the town. (Essential). | The leaderboard should show the current score of all the Connect4 games currently in progress. (Desirable) | The leaderboard should show the current score of all the Connect4 games currently in progress, and any player can click on the entry for a game and spectate that game. (Desirable; might be Extension, depending on the expertise of the team). | The leaderboard should show the lifetime standings of all the players who have ever logged in to this town. (Extension) | . For User Story #5: . | User will be able to join an interactable area which includes leaderboards for all activities (This is too general and should be split in several conditions of satisfactions. For example, joining an area itself can be independent of being able to view leaderboard. Also each activity’s leaderboard should have its own condition of satisfaction. There could be several conditions for leaderboard alone to describe how data is organized) | User is able interact with an instance of interactable area created by another player (This COS is vague. What does interact mean? Does it mean enter an area or do something else?) | User is allowed to join an interactable area of another player in a town if the user was not invited (this sounds wrong, opposite to what the system should be doing) | User is allowed to join an interactable area (Desirable, The priority is wrong. For a user story that requires joining an interable area before anything else, this condition should be considered essential, instead of desirable) | . Reference . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories#conditions-of-satisfaction",
    
    "relUrl": "/tutorials/week1-user-stories#conditions-of-satisfaction"
  },"125": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Conditions of Satisfaction",
    "content": "This tutorial provides examples for user stories, conditions of satisfaction and how a minimum viable product can be defined. Contents: . | User Stories and Conditions of Satisfaction | User Stories and Project Planning | User Stories and Test-Driven Development | Examples | . ",
    "url": "/CS4530-Fall-2024/tutorials/week1-user-stories",
    
    "relUrl": "/tutorials/week1-user-stories"
  }
}
